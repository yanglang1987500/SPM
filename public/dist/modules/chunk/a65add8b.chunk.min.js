webpackJsonp([1],{

/***/ 119:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * git do not control webim.config.js
	 * everyone should copy webim.config.js.demo to webim.config.js
	 * and have their own configs.
	 * In this way , others won't be influenced by this config while git pull.
	 *
	 */
	var config = __webpack_require__(120),appConfig = __webpack_require__(116);

	var WebIM = window.WebIM = {};
	WebIM.config = config[appConfig.WEBIM];
	module.exports = WebIM.config;


/***/ },

/***/ 120:
/***/ function(module, exports) {

	/**
	 * git do not control webim.config.js
	 * everyone should copy webim.config.js.demo to webim.config.js
	 * and have their own configs.
	 * In this way , others won't be influenced by this config while git pull.
	 *
	 */
	if(typeof window == 'undefined'){
	    location = {};
	    navigator = {};
	}

	module.exports = {
	    Ease:{
	        clientId:'YXA6l3XDwLzsEeauIV1NVen0Wg',

	        clientSecret:'YXA6PPwQjnIzclS2KhXKOfba2tAglD4',
	        /*
	         * XMPP server
	         */
	        xmppURL: 'im-api.easemob.com',
	        /*
	         * Backend REST API URL
	         */
	        apiURL: (location.protocol === 'https:' ? 'https:' : 'http:') + '//a1.easemob.com',
	        /*
	         * Application AppKey
	         */
	        appkey: '1112161208178849#spmchat',
	        /*
	         * Whether to use wss
	         * @parameter {Boolean} true or false
	         */
	        https: false,
	        /*
	         * isMultiLoginSessions
	         * true: A visitor can sign in to multiple webpages and receive messages at all the webpages.
	         * false: A visitor can sign in to only one webpage and receive messages at the webpage.
	         */
	        isMultiLoginSessions: true,
	        /*
	         * Set to auto sign-in
	         */
	        isAutoLogin: true,
	        /**
	         * Whether to use window.doQuery()
	         * @parameter {Boolean} true or false
	         */
	        isWindowSDK: false,
	        /**
	         * isSandBox=true:  xmppURL: 'im-api.sandbox.easemob.com',  apiURL: '//a1.sdb.easemob.com',
	         * isSandBox=false: xmppURL: 'im-api.easemob.com',          apiURL: '//a1.easemob.com',
	         * @parameter {Boolean} true or false
	         */
	        isSandBox: false,
	        /**
	         * Whether to console.log in strophe.log()
	         * @parameter {Boolean} true or false
	         */
	        isDebug: false,
	        /**
	         * will auto connect the xmpp server autoReconnectNumMax times in background when client is offline.
	         * won't auto connect if autoReconnectNumMax=0.
	         */
	        autoReconnectNumMax: 2,
	        /**
	         * the interval secons between each atuo reconnectting.
	         * works only if autoReconnectMaxNum >= 2.
	         */
	        autoReconnectInterval: 2,
	        /**
	         * webrtc supports WebKit and https only
	         */
	        isWebRTC: /WebKit/.test(navigator.userAgent) && /^https\:$/.test(window.location.protocol),
	        /**
	         * while http access,use ip directly,instead of ServerName,avoiding DNS problem.
	         */
	        isHttpDNS: false
	    },
	    NIM:{
	        appKey:'cdc261255a39ba1218f97bc505fa924b',
	        appSecret:'3d47c36297a7',
	        nonce:'161616'
	    }

	};


/***/ },

/***/ 121:
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_LOCAL_MODULE_1__;var __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_LOCAL_MODULE_3__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_8__;/*! strophe.js v1.2.8 - built on 16-09-2016 */
	!function(a){if(function(a,b){ true?!(__WEBPACK_LOCAL_MODULE_0__ = function(){return b()}.call(exports, __webpack_require__, exports, module)):a.Base64=b()}(this,function(){var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",b={encode:function(b){var c,d,e,f,g,h,i,j="",k=0;do c=b.charCodeAt(k++),d=b.charCodeAt(k++),e=b.charCodeAt(k++),f=c>>2,g=(3&c)<<4|d>>4,h=(15&d)<<2|e>>6,i=63&e,isNaN(d)?(g=(3&c)<<4,h=i=64):isNaN(e)&&(i=64),j=j+a.charAt(f)+a.charAt(g)+a.charAt(h)+a.charAt(i);while(k<b.length);return j},decode:function(b){var c,d,e,f,g,h,i,j="",k=0;b=b.replace(/[^A-Za-z0-9\+\/\=]/g,"");do f=a.indexOf(b.charAt(k++)),g=a.indexOf(b.charAt(k++)),h=a.indexOf(b.charAt(k++)),i=a.indexOf(b.charAt(k++)),c=f<<2|g>>4,d=(15&g)<<4|h>>2,e=(3&h)<<6|i,j+=String.fromCharCode(c),64!=h&&(j+=String.fromCharCode(d)),64!=i&&(j+=String.fromCharCode(e));while(k<b.length);return j}};return b}),function(a,b){ true?!(__WEBPACK_LOCAL_MODULE_1__ = function(){return b()}.call(exports, __webpack_require__, exports, module)):a.SHA1=b()}(this,function(){function a(a,d){a[d>>5]|=128<<24-d%32,a[(d+64>>9<<4)+15]=d;var g,h,i,j,k,l,m,n,o=new Array(80),p=1732584193,q=-271733879,r=-1732584194,s=271733878,t=-1009589776;for(g=0;g<a.length;g+=16){for(j=p,k=q,l=r,m=s,n=t,h=0;80>h;h++)16>h?o[h]=a[g+h]:o[h]=f(o[h-3]^o[h-8]^o[h-14]^o[h-16],1),i=e(e(f(p,5),b(h,q,r,s)),e(e(t,o[h]),c(h))),t=s,s=r,r=f(q,30),q=p,p=i;p=e(p,j),q=e(q,k),r=e(r,l),s=e(s,m),t=e(t,n)}return[p,q,r,s,t]}function b(a,b,c,d){return 20>a?b&c|~b&d:40>a?b^c^d:60>a?b&c|b&d|c&d:b^c^d}function c(a){return 20>a?1518500249:40>a?1859775393:60>a?-1894007588:-899497514}function d(b,c){var d=g(b);d.length>16&&(d=a(d,8*b.length));for(var e=new Array(16),f=new Array(16),h=0;16>h;h++)e[h]=909522486^d[h],f[h]=1549556828^d[h];var i=a(e.concat(g(c)),512+8*c.length);return a(f.concat(i),672)}function e(a,b){var c=(65535&a)+(65535&b),d=(a>>16)+(b>>16)+(c>>16);return d<<16|65535&c}function f(a,b){return a<<b|a>>>32-b}function g(a){for(var b=[],c=255,d=0;d<8*a.length;d+=8)b[d>>5]|=(a.charCodeAt(d/8)&c)<<24-d%32;return b}function h(a){for(var b="",c=255,d=0;d<32*a.length;d+=8)b+=String.fromCharCode(a[d>>5]>>>24-d%32&c);return b}function i(a){for(var b,c,d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e="",f=0;f<4*a.length;f+=3)for(b=(a[f>>2]>>8*(3-f%4)&255)<<16|(a[f+1>>2]>>8*(3-(f+1)%4)&255)<<8|a[f+2>>2]>>8*(3-(f+2)%4)&255,c=0;4>c;c++)e+=8*f+6*c>32*a.length?"=":d.charAt(b>>6*(3-c)&63);return e}return{b64_hmac_sha1:function(a,b){return i(d(a,b))},b64_sha1:function(b){return i(a(g(b),8*b.length))},binb2str:h,core_hmac_sha1:d,str_hmac_sha1:function(a,b){return h(d(a,b))},str_sha1:function(b){return h(a(g(b),8*b.length))}}}),function(a,b){ true?!(__WEBPACK_LOCAL_MODULE_2__ = function(){return b()}.call(exports, __webpack_require__, exports, module)):a.MD5=b()}(this,function(a){var b=function(a,b){var c=(65535&a)+(65535&b),d=(a>>16)+(b>>16)+(c>>16);return d<<16|65535&c},c=function(a,b){return a<<b|a>>>32-b},d=function(a){for(var b=[],c=0;c<8*a.length;c+=8)b[c>>5]|=(255&a.charCodeAt(c/8))<<c%32;return b},e=function(a){for(var b="",c=0;c<32*a.length;c+=8)b+=String.fromCharCode(a[c>>5]>>>c%32&255);return b},f=function(a){for(var b="0123456789abcdef",c="",d=0;d<4*a.length;d++)c+=b.charAt(a[d>>2]>>d%4*8+4&15)+b.charAt(a[d>>2]>>d%4*8&15);return c},g=function(a,d,e,f,g,h){return b(c(b(b(d,a),b(f,h)),g),e)},h=function(a,b,c,d,e,f,h){return g(b&c|~b&d,a,b,e,f,h)},i=function(a,b,c,d,e,f,h){return g(b&d|c&~d,a,b,e,f,h)},j=function(a,b,c,d,e,f,h){return g(b^c^d,a,b,e,f,h)},k=function(a,b,c,d,e,f,h){return g(c^(b|~d),a,b,e,f,h)},l=function(a,c){a[c>>5]|=128<<c%32,a[(c+64>>>9<<4)+14]=c;for(var d,e,f,g,l=1732584193,m=-271733879,n=-1732584194,o=271733878,p=0;p<a.length;p+=16)d=l,e=m,f=n,g=o,l=h(l,m,n,o,a[p+0],7,-680876936),o=h(o,l,m,n,a[p+1],12,-389564586),n=h(n,o,l,m,a[p+2],17,606105819),m=h(m,n,o,l,a[p+3],22,-1044525330),l=h(l,m,n,o,a[p+4],7,-176418897),o=h(o,l,m,n,a[p+5],12,1200080426),n=h(n,o,l,m,a[p+6],17,-1473231341),m=h(m,n,o,l,a[p+7],22,-45705983),l=h(l,m,n,o,a[p+8],7,1770035416),o=h(o,l,m,n,a[p+9],12,-1958414417),n=h(n,o,l,m,a[p+10],17,-42063),m=h(m,n,o,l,a[p+11],22,-1990404162),l=h(l,m,n,o,a[p+12],7,1804603682),o=h(o,l,m,n,a[p+13],12,-40341101),n=h(n,o,l,m,a[p+14],17,-1502002290),m=h(m,n,o,l,a[p+15],22,1236535329),l=i(l,m,n,o,a[p+1],5,-165796510),o=i(o,l,m,n,a[p+6],9,-1069501632),n=i(n,o,l,m,a[p+11],14,643717713),m=i(m,n,o,l,a[p+0],20,-373897302),l=i(l,m,n,o,a[p+5],5,-701558691),o=i(o,l,m,n,a[p+10],9,38016083),n=i(n,o,l,m,a[p+15],14,-660478335),m=i(m,n,o,l,a[p+4],20,-405537848),l=i(l,m,n,o,a[p+9],5,568446438),o=i(o,l,m,n,a[p+14],9,-1019803690),n=i(n,o,l,m,a[p+3],14,-187363961),m=i(m,n,o,l,a[p+8],20,1163531501),l=i(l,m,n,o,a[p+13],5,-1444681467),o=i(o,l,m,n,a[p+2],9,-51403784),n=i(n,o,l,m,a[p+7],14,1735328473),m=i(m,n,o,l,a[p+12],20,-1926607734),l=j(l,m,n,o,a[p+5],4,-378558),o=j(o,l,m,n,a[p+8],11,-2022574463),n=j(n,o,l,m,a[p+11],16,1839030562),m=j(m,n,o,l,a[p+14],23,-35309556),l=j(l,m,n,o,a[p+1],4,-1530992060),o=j(o,l,m,n,a[p+4],11,1272893353),n=j(n,o,l,m,a[p+7],16,-155497632),m=j(m,n,o,l,a[p+10],23,-1094730640),l=j(l,m,n,o,a[p+13],4,681279174),o=j(o,l,m,n,a[p+0],11,-358537222),n=j(n,o,l,m,a[p+3],16,-722521979),m=j(m,n,o,l,a[p+6],23,76029189),l=j(l,m,n,o,a[p+9],4,-640364487),o=j(o,l,m,n,a[p+12],11,-421815835),n=j(n,o,l,m,a[p+15],16,530742520),m=j(m,n,o,l,a[p+2],23,-995338651),l=k(l,m,n,o,a[p+0],6,-198630844),o=k(o,l,m,n,a[p+7],10,1126891415),n=k(n,o,l,m,a[p+14],15,-1416354905),m=k(m,n,o,l,a[p+5],21,-57434055),l=k(l,m,n,o,a[p+12],6,1700485571),o=k(o,l,m,n,a[p+3],10,-1894986606),n=k(n,o,l,m,a[p+10],15,-1051523),m=k(m,n,o,l,a[p+1],21,-2054922799),l=k(l,m,n,o,a[p+8],6,1873313359),o=k(o,l,m,n,a[p+15],10,-30611744),n=k(n,o,l,m,a[p+6],15,-1560198380),m=k(m,n,o,l,a[p+13],21,1309151649),l=k(l,m,n,o,a[p+4],6,-145523070),o=k(o,l,m,n,a[p+11],10,-1120210379),n=k(n,o,l,m,a[p+2],15,718787259),m=k(m,n,o,l,a[p+9],21,-343485551),l=b(l,d),m=b(m,e),n=b(n,f),o=b(o,g);return[l,m,n,o]},m={hexdigest:function(a){return f(l(d(a),8*a.length))},hash:function(a){return e(l(d(a),8*a.length))}};return m}),function(a,b){ true?!(__WEBPACK_LOCAL_MODULE_3__ = function(){return b()}.call(exports, __webpack_require__, exports, module)):a.stropheUtils=b()}(this,function(){var a={utf16to8:function(a){var b,c,d="",e=a.length;for(b=0;e>b;b++)c=a.charCodeAt(b),c>=0&&127>=c?d+=a.charAt(b):c>2047?(d+=String.fromCharCode(224|c>>12&15),d+=String.fromCharCode(128|c>>6&63),d+=String.fromCharCode(128|c>>0&63)):(d+=String.fromCharCode(192|c>>6&31),d+=String.fromCharCode(128|c>>0&63));return d},addCookies:function(a){var b,c,d,e,f,g,h;for(b in a||{})f="",g="",h="",c=a[b],d="object"==typeof c,e=escape(unescape(d?c.value:c)),d&&(f=c.expires?";expires="+c.expires:"",g=c.domain?";domain="+c.domain:"",h=c.path?";path="+c.path:""),document.cookie=b+"="+e+f+g+h}};return a}),function(a,b){return true?void !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_4__ = (function(){return b()}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):b()}(this,function(){Function.prototype.bind||(Function.prototype.bind=function(a){var b=this,c=Array.prototype.slice,d=Array.prototype.concat,e=c.call(arguments,1);return function(){return b.apply(a?a:this,d.call(e,c.call(arguments,0)))}}),Array.isArray||(Array.isArray=function(a){return"[object Array]"===Object.prototype.toString.call(a)}),Array.prototype.indexOf||(Array.prototype.indexOf=function(a){var b=this.length,c=Number(arguments[1])||0;for(c=0>c?Math.ceil(c):Math.floor(c),0>c&&(c+=b);b>c;c++)if(c in this&&this[c]===a)return c;return-1})}),function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_0__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_3__,__WEBPACK_LOCAL_MODULE_4__], __WEBPACK_LOCAL_MODULE_5__ = (function(){return b.apply(this,arguments)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));else{var c=b(a.SHA1,a.Base64,a.MD5,a.stropheUtils);window.Strophe=c.Strophe,window.$build=c.$build,window.$iq=c.$iq,window.$msg=c.$msg,window.$pres=c.$pres,window.SHA1=c.SHA1,window.Base64=c.Base64,window.MD5=c.MD5,window.b64_hmac_sha1=c.SHA1.b64_hmac_sha1,window.b64_sha1=c.SHA1.b64_sha1,window.str_hmac_sha1=c.SHA1.str_hmac_sha1,window.str_sha1=c.SHA1.str_sha1}}(this,function(a,b,c,d){function e(a,b){return new i.Builder(a,b)}function f(a){return new i.Builder("message",a)}function g(a){return new i.Builder("iq",a)}function h(a){return new i.Builder("presence",a)}var i;return i={VERSION:"1.2.8",NS:{HTTPBIND:"http://jabber.org/protocol/httpbind",BOSH:"urn:xmpp:xbosh",CLIENT:"jabber:client",AUTH:"jabber:iq:auth",ROSTER:"jabber:iq:roster",PROFILE:"jabber:iq:profile",DISCO_INFO:"http://jabber.org/protocol/disco#info",DISCO_ITEMS:"http://jabber.org/protocol/disco#items",MUC:"http://jabber.org/protocol/muc",SASL:"urn:ietf:params:xml:ns:xmpp-sasl",STREAM:"http://etherx.jabber.org/streams",FRAMING:"urn:ietf:params:xml:ns:xmpp-framing",BIND:"urn:ietf:params:xml:ns:xmpp-bind",SESSION:"urn:ietf:params:xml:ns:xmpp-session",VERSION:"jabber:iq:version",STANZAS:"urn:ietf:params:xml:ns:xmpp-stanzas",XHTML_IM:"http://jabber.org/protocol/xhtml-im",XHTML:"http://www.w3.org/1999/xhtml"},XHTML:{tags:["a","blockquote","br","cite","em","img","li","ol","p","span","strong","ul","body"],attributes:{a:["href"],blockquote:["style"],br:[],cite:["style"],em:[],img:["src","alt","style","height","width"],li:["style"],ol:["style"],p:["style"],span:["style"],strong:[],ul:["style"],body:[]},css:["background-color","color","font-family","font-size","font-style","font-weight","margin-left","margin-right","text-align","text-decoration"],validTag:function(a){for(var b=0;b<i.XHTML.tags.length;b++)if(a==i.XHTML.tags[b])return!0;return!1},validAttribute:function(a,b){if("undefined"!=typeof i.XHTML.attributes[a]&&i.XHTML.attributes[a].length>0)for(var c=0;c<i.XHTML.attributes[a].length;c++)if(b==i.XHTML.attributes[a][c])return!0;return!1},validCSS:function(a){for(var b=0;b<i.XHTML.css.length;b++)if(a==i.XHTML.css[b])return!0;return!1}},Status:{ERROR:0,CONNECTING:1,CONNFAIL:2,AUTHENTICATING:3,AUTHFAIL:4,CONNECTED:5,DISCONNECTED:6,DISCONNECTING:7,ATTACHED:8,REDIRECT:9,CONNTIMEOUT:10},LogLevel:{DEBUG:0,INFO:1,WARN:2,ERROR:3,FATAL:4},ElementType:{NORMAL:1,TEXT:3,CDATA:4,FRAGMENT:11},TIMEOUT:1.1,SECONDARY_TIMEOUT:.1,addNamespace:function(a,b){i.NS[a]=b},forEachChild:function(a,b,c){var d,e;for(d=0;d<a.childNodes.length;d++)e=a.childNodes[d],e.nodeType!=i.ElementType.NORMAL||b&&!this.isTagEqual(e,b)||c(e)},isTagEqual:function(a,b){return a.tagName==b},_xmlGenerator:null,_makeGenerator:function(){var a;return void 0===document.implementation.createDocument||document.implementation.createDocument&&document.documentMode&&document.documentMode<10?(a=this._getIEXmlDom(),a.appendChild(a.createElement("strophe"))):a=document.implementation.createDocument("jabber:client","strophe",null),a},xmlGenerator:function(){return i._xmlGenerator||(i._xmlGenerator=i._makeGenerator()),i._xmlGenerator},_getIEXmlDom:function(){for(var a=null,b=["Msxml2.DOMDocument.6.0","Msxml2.DOMDocument.5.0","Msxml2.DOMDocument.4.0","MSXML2.DOMDocument.3.0","MSXML2.DOMDocument","MSXML.DOMDocument","Microsoft.XMLDOM"],c=0;c<b.length&&null===a;c++)try{a=new ActiveXObject(b[c])}catch(d){a=null}return a},xmlElement:function(a){if(!a)return null;var b,c,d,e=i.xmlGenerator().createElement(a);for(b=1;b<arguments.length;b++){var f=arguments[b];if(f)if("string"==typeof f||"number"==typeof f)e.appendChild(i.xmlTextNode(f));else if("object"==typeof f&&"function"==typeof f.sort)for(c=0;c<f.length;c++){var g=f[c];"object"==typeof g&&"function"==typeof g.sort&&void 0!==g[1]&&null!==g[1]&&e.setAttribute(g[0],g[1])}else if("object"==typeof f)for(d in f)f.hasOwnProperty(d)&&void 0!==f[d]&&null!==f[d]&&e.setAttribute(d,f[d])}return e},xmlescape:function(a){return a=a.replace(/\&/g,"&amp;"),a=a.replace(/</g,"&lt;"),a=a.replace(/>/g,"&gt;"),a=a.replace(/'/g,"&apos;"),a=a.replace(/"/g,"&quot;")},xmlunescape:function(a){return a=a.replace(/\&amp;/g,"&"),a=a.replace(/&lt;/g,"<"),a=a.replace(/&gt;/g,">"),a=a.replace(/&apos;/g,"'"),a=a.replace(/&quot;/g,'"')},xmlTextNode:function(a){return i.xmlGenerator().createTextNode(a)},xmlHtmlNode:function(a){var b;if(window.DOMParser){var c=new DOMParser;b=c.parseFromString(a,"text/xml")}else b=new ActiveXObject("Microsoft.XMLDOM"),b.async="false",b.loadXML(a);return b},getText:function(a){if(!a)return null;var b="";0===a.childNodes.length&&a.nodeType==i.ElementType.TEXT&&(b+=a.nodeValue);for(var c=0;c<a.childNodes.length;c++)a.childNodes[c].nodeType==i.ElementType.TEXT&&(b+=a.childNodes[c].nodeValue);return i.xmlescape(b)},copyElement:function(a){var b,c;if(a.nodeType==i.ElementType.NORMAL){for(c=i.xmlElement(a.tagName),b=0;b<a.attributes.length;b++)c.setAttribute(a.attributes[b].nodeName,a.attributes[b].value);for(b=0;b<a.childNodes.length;b++)c.appendChild(i.copyElement(a.childNodes[b]))}else a.nodeType==i.ElementType.TEXT&&(c=i.xmlGenerator().createTextNode(a.nodeValue));return c},createHtml:function(a){var b,c,d,e,f,g,h,j,k,l,m;if(a.nodeType==i.ElementType.NORMAL)if(e=a.nodeName.toLowerCase(),i.XHTML.validTag(e))try{for(c=i.xmlElement(e),b=0;b<i.XHTML.attributes[e].length;b++)if(f=i.XHTML.attributes[e][b],g=a.getAttribute(f),"undefined"!=typeof g&&null!==g&&""!==g&&g!==!1&&0!==g)if("style"==f&&"object"==typeof g&&"undefined"!=typeof g.cssText&&(g=g.cssText),"style"==f){for(h=[],j=g.split(";"),d=0;d<j.length;d++)k=j[d].split(":"),l=k[0].replace(/^\s*/,"").replace(/\s*$/,"").toLowerCase(),i.XHTML.validCSS(l)&&(m=k[1].replace(/^\s*/,"").replace(/\s*$/,""),h.push(l+": "+m));h.length>0&&(g=h.join("; "),c.setAttribute(f,g))}else c.setAttribute(f,g);for(b=0;b<a.childNodes.length;b++)c.appendChild(i.createHtml(a.childNodes[b]))}catch(n){c=i.xmlTextNode("")}else for(c=i.xmlGenerator().createDocumentFragment(),b=0;b<a.childNodes.length;b++)c.appendChild(i.createHtml(a.childNodes[b]));else if(a.nodeType==i.ElementType.FRAGMENT)for(c=i.xmlGenerator().createDocumentFragment(),b=0;b<a.childNodes.length;b++)c.appendChild(i.createHtml(a.childNodes[b]));else a.nodeType==i.ElementType.TEXT&&(c=i.xmlTextNode(a.nodeValue));return c},escapeNode:function(a){return"string"!=typeof a?a:a.replace(/^\s+|\s+$/g,"").replace(/\\/g,"\\5c").replace(/ /g,"\\20").replace(/\"/g,"\\22").replace(/\&/g,"\\26").replace(/\'/g,"\\27").replace(/\//g,"\\2f").replace(/:/g,"\\3a").replace(/</g,"\\3c").replace(/>/g,"\\3e").replace(/@/g,"\\40")},unescapeNode:function(a){return"string"!=typeof a?a:a.replace(/\\20/g," ").replace(/\\22/g,'"').replace(/\\26/g,"&").replace(/\\27/g,"'").replace(/\\2f/g,"/").replace(/\\3a/g,":").replace(/\\3c/g,"<").replace(/\\3e/g,">").replace(/\\40/g,"@").replace(/\\5c/g,"\\")},getNodeFromJid:function(a){return a.indexOf("@")<0?null:a.split("@")[0]},getDomainFromJid:function(a){var b=i.getBareJidFromJid(a);if(b.indexOf("@")<0)return b;var c=b.split("@");return c.splice(0,1),c.join("@")},getResourceFromJid:function(a){var b=a.split("/");return b.length<2?null:(b.splice(0,1),b.join("/"))},getBareJidFromJid:function(a){return a?a.split("/")[0]:null},log:function(a,b){},debug:function(a){this.log(this.LogLevel.DEBUG,a)},info:function(a){this.log(this.LogLevel.INFO,a)},warn:function(a){this.log(this.LogLevel.WARN,a)},error:function(a){this.log(this.LogLevel.ERROR,a)},fatal:function(a){this.log(this.LogLevel.FATAL,a)},serialize:function(a){var b;if(!a)return null;"function"==typeof a.tree&&(a=a.tree());var c,d,e=a.nodeName;for(a.getAttribute("_realname")&&(e=a.getAttribute("_realname")),b="<"+e,c=0;c<a.attributes.length;c++)"_realname"!=a.attributes[c].nodeName&&(b+=" "+a.attributes[c].nodeName+"='"+i.xmlescape(a.attributes[c].value)+"'");if(a.childNodes.length>0){for(b+=">",c=0;c<a.childNodes.length;c++)switch(d=a.childNodes[c],d.nodeType){case i.ElementType.NORMAL:b+=i.serialize(d);break;case i.ElementType.TEXT:b+=i.xmlescape(d.nodeValue);break;case i.ElementType.CDATA:b+="<![CDATA["+d.nodeValue+"]]>"}b+="</"+e+">"}else b+="/>";return b},_requestId:0,_connectionPlugins:{},addConnectionPlugin:function(a,b){i._connectionPlugins[a]=b}},i.Builder=function(a,b){("presence"==a||"message"==a||"iq"==a)&&(b&&!b.xmlns?b.xmlns=i.NS.CLIENT:b||(b={xmlns:i.NS.CLIENT})),this.nodeTree=i.xmlElement(a,b),this.node=this.nodeTree},i.Builder.prototype={tree:function(){return this.nodeTree},toString:function(){return i.serialize(this.nodeTree)},up:function(){return this.node=this.node.parentNode,this},attrs:function(a){for(var b in a)a.hasOwnProperty(b)&&(void 0===a[b]?this.node.removeAttribute(b):this.node.setAttribute(b,a[b]));return this},c:function(a,b,c){var d=i.xmlElement(a,b,c);return this.node.appendChild(d),"string"!=typeof c&&"number"!=typeof c&&(this.node=d),this},cnode:function(a){var b,c=i.xmlGenerator();try{b=void 0!==c.importNode}catch(d){b=!1}var e=b?c.importNode(a,!0):i.copyElement(a);return this.node.appendChild(e),this.node=e,this},t:function(a){var b=i.xmlTextNode(a);return this.node.appendChild(b),this},h:function(a){var b=document.createElement("body");b.innerHTML=a;for(var c=i.createHtml(b);c.childNodes.length>0;)this.node.appendChild(c.childNodes[0]);return this}},i.Handler=function(a,b,c,d,e,f,g){this.handler=a,this.ns=b,this.name=c,this.type=d,this.id=e,this.options=g||{matchBare:!1},this.options.matchBare||(this.options.matchBare=!1),this.options.matchBare?this.from=f?i.getBareJidFromJid(f):null:this.from=f,this.user=!0},i.Handler.prototype={isMatch:function(a){var b,c=null;if(c=this.options.matchBare?i.getBareJidFromJid(a.getAttribute("from")):a.getAttribute("from"),b=!1,this.ns){var d=this;i.forEachChild(a,null,function(a){a.getAttribute("xmlns")==d.ns&&(b=!0)}),b=b||a.getAttribute("xmlns")==this.ns}else b=!0;var e=a.getAttribute("type");return!b||this.name&&!i.isTagEqual(a,this.name)||this.type&&(Array.isArray(this.type)?-1==this.type.indexOf(e):e!=this.type)||this.id&&a.getAttribute("id")!=this.id||this.from&&c!=this.from?!1:!0},run:function(a){var b=null;try{b=this.handler(a)}catch(c){throw c.sourceURL?i.fatal("error: "+this.handler+" "+c.sourceURL+":"+c.line+" - "+c.name+": "+c.message):c.fileName?("undefined"!=typeof console&&(console.trace(),console.error(this.handler," - error - ",c,c.message)),i.fatal("error: "+this.handler+" "+c.fileName+":"+c.lineNumber+" - "+c.name+": "+c.message)):i.fatal("error: "+c.message+"\n"+c.stack),c}return b},toString:function(){return"{Handler: "+this.handler+"("+this.name+","+this.id+","+this.ns+")}"}},i.TimedHandler=function(a,b){this.period=a,this.handler=b,this.lastCalled=(new Date).getTime(),this.user=!0},i.TimedHandler.prototype={run:function(){return this.lastCalled=(new Date).getTime(),this.handler()},reset:function(){this.lastCalled=(new Date).getTime()},toString:function(){return"{TimedHandler: "+this.handler+"("+this.period+")}"}},i.Connection=function(a,b){this.service=a,this.options=b||{};var c=this.options.protocol||"";0===a.indexOf("ws:")||0===a.indexOf("wss:")||0===c.indexOf("ws")?this._proto=new i.Websocket(this):this._proto=new i.Bosh(this),this.jid="",this.domain=null,this.features=null,this._sasl_data={},this.do_session=!1,this.do_bind=!1,this.timedHandlers=[],this.handlers=[],this.removeTimeds=[],this.removeHandlers=[],this.addTimeds=[],this.addHandlers=[],this._authentication={},this._idleTimeout=null,this._disconnectTimeout=null,this.authenticated=!1,this.connected=!1,this.disconnecting=!1,this.do_authentication=!0,this.paused=!1,this.restored=!1,this._data=[],this._uniqueId=0,this._sasl_success_handler=null,this._sasl_failure_handler=null,this._sasl_challenge_handler=null,this.maxRetries=5,this._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this),100),d.addCookies(this.options.cookies);for(var e in i._connectionPlugins)if(i._connectionPlugins.hasOwnProperty(e)){var f=i._connectionPlugins[e],g=function(){};g.prototype=f,this[e]=new g,this[e].init(this)}},i.Connection.prototype={reset:function(){this._proto._reset(),this.do_session=!1,this.do_bind=!1,this.timedHandlers=[],this.handlers=[],this.removeTimeds=[],this.removeHandlers=[],this.addTimeds=[],this.addHandlers=[],this._authentication={},this.authenticated=!1,this.connected=!1,this.disconnecting=!1,this.restored=!1,this._data=[],this._requests=[],this._uniqueId=0},pause:function(){this.paused=!0},resume:function(){this.paused=!1},getUniqueId:function(a){var b="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(a){var b=16*Math.random()|0,c="x"==a?b:3&b|8;return c.toString(16)});return"string"==typeof a||"number"==typeof a?b+":"+a:b+""},connect:function(a,b,c,d,e,f,g){this.jid=a,this.authzid=i.getBareJidFromJid(this.jid),this.authcid=g||i.getNodeFromJid(this.jid),this.pass=b,this.servtype="xmpp",this.connect_callback=c,this.disconnecting=!1,this.connected=!1,this.authenticated=!1,this.restored=!1,this.domain=i.getDomainFromJid(this.jid),this._changeConnectStatus(i.Status.CONNECTING,null),this._proto._connect(d,e,f)},attach:function(a,b,c,d,e,f,g){if(!(this._proto instanceof i.Bosh))throw{name:"StropheSessionError",message:'The "attach" method can only be used with a BOSH connection.'};this._proto._attach(a,b,c,d,e,f,g)},restore:function(a,b,c,d,e){if(!this._sessionCachingSupported())throw{name:"StropheSessionError",message:'The "restore" method can only be used with a BOSH connection.'};this._proto._restore(a,b,c,d,e)},_sessionCachingSupported:function(){if(this._proto instanceof i.Bosh){if(!JSON)return!1;try{window.sessionStorage.setItem("_strophe_","_strophe_"),window.sessionStorage.removeItem("_strophe_")}catch(a){return!1}return!0}return!1},xmlInput:function(a){},xmlOutput:function(a){},rawInput:function(a){},rawOutput:function(a){},nextValidRid:function(a){},send:function(a){if(null!==a){if("function"==typeof a.sort)for(var b=0;b<a.length;b++)this._queueData(a[b]);else"function"==typeof a.tree?this._queueData(a.tree()):this._queueData(a);this._proto._send()}},flush:function(){clearTimeout(this._idleTimeout),this._onIdle()},sendIQ:function(a,b,c,d){var e=null,f=this;"function"==typeof a.tree&&(a=a.tree());var g=a.getAttribute("id");g||(g=this.getUniqueId("sendIQ"),a.setAttribute("id",g));var h=a.getAttribute("to"),j=this.jid,k=this.addHandler(function(a){e&&f.deleteTimedHandler(e);var d=!1,g=a.getAttribute("from");if(g!==h&&(h||g!==i.getBareJidFromJid(j)&&g!==i.getDomainFromJid(j)&&g!==j)||(d=!0),!d)throw{name:"StropheError",message:"Got answer to IQ from wrong jid:"+g+"\nExpected jid: "+h};var k=a.getAttribute("type");if("result"==k)b&&b(a);else{if("error"!=k)throw{name:"StropheError",message:"Got bad IQ type of "+k};c&&c(a)}},null,"iq",["error","result"],g);return d&&(e=this.addTimedHandler(d,function(){return f.deleteHandler(k),c&&c(null),!1})),this.send(a),g},_queueData:function(a){if(null===a||!a.tagName||!a.childNodes)throw{name:"StropheError",message:"Cannot queue non-DOMElement."};this._data.push(a)},_sendRestart:function(){this._data.push("restart"),this._proto._sendRestart(),this._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this),100)},addTimedHandler:function(a,b){var c=new i.TimedHandler(a,b);return this.addTimeds.push(c),c},deleteTimedHandler:function(a){this.removeTimeds.push(a)},addHandler:function(a,b,c,d,e,f,g){var h=new i.Handler(a,b,c,d,e,f,g);return this.addHandlers.push(h),h},deleteHandler:function(a){this.removeHandlers.push(a);var b=this.addHandlers.indexOf(a);b>=0&&this.addHandlers.splice(b,1)},disconnect:function(a){if(this._changeConnectStatus(i.Status.DISCONNECTING,a),i.info("Disconnect was called because: "+a),this.connected){var b=!1;this.disconnecting=!0,this.authenticated&&(b=h({xmlns:i.NS.CLIENT,type:"unavailable"})),this._disconnectTimeout=this._addSysTimedHandler(3e3,this._onDisconnectTimeout.bind(this)),this._proto._disconnect(b)}else i.info("Disconnect was called before Strophe connected to the server"),this._proto._abortAllRequests()},_changeConnectStatus:function(a,b){for(var c in i._connectionPlugins)if(i._connectionPlugins.hasOwnProperty(c)){var d=this[c];if(d.statusChanged)try{d.statusChanged(a,b)}catch(e){i.error(""+c+" plugin caused an exception changing status: "+e)}}if(this.connect_callback)try{this.connect_callback(a,b)}catch(f){i.error("User connection callback caused an exception: "+f)}},_doDisconnect:function(a){"number"==typeof this._idleTimeout&&clearTimeout(this._idleTimeout),null!==this._disconnectTimeout&&(this.deleteTimedHandler(this._disconnectTimeout),this._disconnectTimeout=null),i.info("_doDisconnect was called"),this._proto._doDisconnect(),this.authenticated=!1,this.disconnecting=!1,this.restored=!1,this.handlers=[],this.timedHandlers=[],this.removeTimeds=[],this.removeHandlers=[],this.addTimeds=[],this.addHandlers=[],this._changeConnectStatus(i.Status.DISCONNECTED,a),this.connected=!1},_dataRecv:function(a,b){i.info("_dataRecv called");var c=this._proto._reqToData(a);if(null!==c){this.xmlInput!==i.Connection.prototype.xmlInput&&(c.nodeName===this._proto.strip&&c.childNodes.length?this.xmlInput(c.childNodes[0]):this.xmlInput(c)),this.rawInput!==i.Connection.prototype.rawInput&&(b?this.rawInput(b):this.rawInput(i.serialize(c)));for(var d,e;this.removeHandlers.length>0;)e=this.removeHandlers.pop(),d=this.handlers.indexOf(e),d>=0&&this.handlers.splice(d,1);for(;this.addHandlers.length>0;)this.handlers.push(this.addHandlers.pop());if(this.disconnecting&&this._proto._emptyQueue())return void this._doDisconnect();var f,g,h=c.getAttribute("type");if(null!==h&&"terminate"==h){if(this.disconnecting)return;return f=c.getAttribute("condition"),g=c.getElementsByTagName("conflict"),null!==f?("remote-stream-error"==f&&g.length>0&&(f="conflict"),this._changeConnectStatus(i.Status.CONNFAIL,f)):this._changeConnectStatus(i.Status.CONNFAIL,"unknown"),void this._doDisconnect(f)}var j=this;i.forEachChild(c,null,function(a){var b,c;for(c=j.handlers,j.handlers=[],b=0;b<c.length;b++){var d=c[b];try{!d.isMatch(a)||!j.authenticated&&d.user?j.handlers.push(d):d.run(a)&&j.handlers.push(d)}catch(e){i.warn("Removing Strophe handlers due to uncaught exception: "+e.message)}}})}},mechanisms:{},_connect_cb:function(a,b,c){i.info("_connect_cb was called"),this.connected=!0;var d;try{d=this._proto._reqToData(a)}catch(e){if("badformat"!=e)throw e;this._changeConnectStatus(i.Status.CONNFAIL,"bad-format"),this._doDisconnect("bad-format")}if(d){this.xmlInput!==i.Connection.prototype.xmlInput&&(d.nodeName===this._proto.strip&&d.childNodes.length?this.xmlInput(d.childNodes[0]):this.xmlInput(d)),this.rawInput!==i.Connection.prototype.rawInput&&(c?this.rawInput(c):this.rawInput(i.serialize(d)));var f=this._proto._connect_cb(d);if(f!==i.Status.CONNFAIL){this._authentication.sasl_scram_sha1=!1,this._authentication.sasl_plain=!1,this._authentication.sasl_digest_md5=!1,this._authentication.sasl_anonymous=!1,this._authentication.legacy_auth=!1;var g;g=d.getElementsByTagNameNS?d.getElementsByTagNameNS(i.NS.STREAM,"features").length>0:d.getElementsByTagName("stream:features").length>0||d.getElementsByTagName("features").length>0;var h,j,k=d.getElementsByTagName("mechanism"),l=[],m=!1;if(!g)return void this._proto._no_auth_received(b);if(k.length>0)for(h=0;h<k.length;h++)j=i.getText(k[h]),this.mechanisms[j]&&l.push(this.mechanisms[j]);return this._authentication.legacy_auth=d.getElementsByTagName("auth").length>0,(m=this._authentication.legacy_auth||l.length>0)?void(this.do_authentication!==!1&&this.authenticate(l)):void this._proto._no_auth_received(b)}}},authenticate:function(a){var c;for(c=0;c<a.length-1;++c){for(var d=c,f=c+1;f<a.length;++f)a[f].prototype.priority>a[d].prototype.priority&&(d=f);if(d!=c){var h=a[c];a[c]=a[d],a[d]=h}}var j=!1;for(c=0;c<a.length;++c)if(a[c].prototype.test(this)){this._sasl_success_handler=this._addSysHandler(this._sasl_success_cb.bind(this),null,"success",null,null),this._sasl_failure_handler=this._addSysHandler(this._sasl_failure_cb.bind(this),null,"failure",null,null),this._sasl_challenge_handler=this._addSysHandler(this._sasl_challenge_cb.bind(this),null,"challenge",null,null),this._sasl_mechanism=new a[c],this._sasl_mechanism.onStart(this);var k=e("auth",{xmlns:i.NS.SASL,mechanism:this._sasl_mechanism.name});if(this._sasl_mechanism.isClientFirst){var l=this._sasl_mechanism.onChallenge(this,null);k.t(b.encode(l))}this.send(k.tree()),j=!0;break}j||(null===i.getNodeFromJid(this.jid)?(this._changeConnectStatus(i.Status.CONNFAIL,"x-strophe-bad-non-anon-jid"),this.disconnect("x-strophe-bad-non-anon-jid")):(this._changeConnectStatus(i.Status.AUTHENTICATING,null),this._addSysHandler(this._auth1_cb.bind(this),null,null,null,"_auth_1"),this.send(g({type:"get",to:this.domain,id:"_auth_1"}).c("query",{xmlns:i.NS.AUTH}).c("username",{}).t(i.getNodeFromJid(this.jid)).tree())))},_sasl_challenge_cb:function(a){var c=b.decode(i.getText(a)),d=this._sasl_mechanism.onChallenge(this,c),f=e("response",{xmlns:i.NS.SASL});return""!==d&&f.t(b.encode(d)),this.send(f.tree()),!0},_auth1_cb:function(a){var b=g({type:"set",id:"_auth_2"}).c("query",{xmlns:i.NS.AUTH}).c("username",{}).t(i.getNodeFromJid(this.jid)).up().c("password").t(this.pass);return i.getResourceFromJid(this.jid)||(this.jid=i.getBareJidFromJid(this.jid)+"/strophe"),b.up().c("resource",{}).t(i.getResourceFromJid(this.jid)),this._addSysHandler(this._auth2_cb.bind(this),null,null,null,"_auth_2"),this.send(b.tree()),!1},_sasl_success_cb:function(a){if(this._sasl_data["server-signature"]){var c,d=b.decode(i.getText(a)),e=/([a-z]+)=([^,]+)(,|$)/,f=d.match(e);if("v"==f[1]&&(c=f[2]),c!=this._sasl_data["server-signature"])return this.deleteHandler(this._sasl_failure_handler),this._sasl_failure_handler=null,this._sasl_challenge_handler&&(this.deleteHandler(this._sasl_challenge_handler),this._sasl_challenge_handler=null),this._sasl_data={},this._sasl_failure_cb(null)}i.info("SASL authentication succeeded."),this._sasl_mechanism&&this._sasl_mechanism.onSuccess(),this.deleteHandler(this._sasl_failure_handler),this._sasl_failure_handler=null,this._sasl_challenge_handler&&(this.deleteHandler(this._sasl_challenge_handler),this._sasl_challenge_handler=null);var g=[],h=function(a,b){for(;a.length;)this.deleteHandler(a.pop());return this._sasl_auth1_cb.bind(this)(b),!1};return g.push(this._addSysHandler(function(a){h.bind(this)(g,a)}.bind(this),null,"stream:features",null,null)),g.push(this._addSysHandler(function(a){h.bind(this)(g,a)}.bind(this),i.NS.STREAM,"features",null,null)),this._sendRestart(),!1},_sasl_auth1_cb:function(a){this.features=a;var b,c;for(b=0;b<a.childNodes.length;b++)c=a.childNodes[b],"bind"==c.nodeName&&(this.do_bind=!0),"session"==c.nodeName&&(this.do_session=!0);if(!this.do_bind)return this._changeConnectStatus(i.Status.AUTHFAIL,null),!1;this._addSysHandler(this._sasl_bind_cb.bind(this),null,null,null,"_bind_auth_2");var d=i.getResourceFromJid(this.jid);return d?this.send(g({type:"set",id:"_bind_auth_2"}).c("bind",{xmlns:i.NS.BIND}).c("resource",{}).t(d).tree()):this.send(g({type:"set",id:"_bind_auth_2"}).c("bind",{xmlns:i.NS.BIND}).tree()),!1},_sasl_bind_cb:function(a){if("error"==a.getAttribute("type")){i.info("SASL binding failed.");var b,c=a.getElementsByTagName("conflict");return c.length>0&&(b="conflict"),this._changeConnectStatus(i.Status.AUTHFAIL,b),!1}var d,e=a.getElementsByTagName("bind");return e.length>0?(d=e[0].getElementsByTagName("jid"),void(d.length>0&&(this.jid=i.getText(d[0]),this.do_session?(this._addSysHandler(this._sasl_session_cb.bind(this),null,null,null,"_session_auth_2"),this.send(g({type:"set",id:"_session_auth_2"}).c("session",{xmlns:i.NS.SESSION}).tree())):(this.authenticated=!0,this._changeConnectStatus(i.Status.CONNECTED,null))))):(i.info("SASL binding failed."),this._changeConnectStatus(i.Status.AUTHFAIL,null),!1)},_sasl_session_cb:function(a){if("result"==a.getAttribute("type"))this.authenticated=!0,this._changeConnectStatus(i.Status.CONNECTED,null);else if("error"==a.getAttribute("type"))return i.info("Session creation failed."),this._changeConnectStatus(i.Status.AUTHFAIL,null),!1;return!1},_sasl_failure_cb:function(a){return this._sasl_success_handler&&(this.deleteHandler(this._sasl_success_handler),this._sasl_success_handler=null),this._sasl_challenge_handler&&(this.deleteHandler(this._sasl_challenge_handler),this._sasl_challenge_handler=null),this._sasl_mechanism&&this._sasl_mechanism.onFailure(),
	this._changeConnectStatus(i.Status.AUTHFAIL,null),!1},_auth2_cb:function(a){return"result"==a.getAttribute("type")?(this.authenticated=!0,this._changeConnectStatus(i.Status.CONNECTED,null)):"error"==a.getAttribute("type")&&(this._changeConnectStatus(i.Status.AUTHFAIL,null),this.disconnect("authentication failed")),!1},_addSysTimedHandler:function(a,b){var c=new i.TimedHandler(a,b);return c.user=!1,this.addTimeds.push(c),c},_addSysHandler:function(a,b,c,d,e){var f=new i.Handler(a,b,c,d,e);return f.user=!1,this.addHandlers.push(f),f},_onDisconnectTimeout:function(){return i.info("_onDisconnectTimeout was called"),this._changeConnectStatus(i.Status.CONNTIMEOUT,null),this._proto._onDisconnectTimeout(),this._doDisconnect(),!1},_onIdle:function(){for(var a,b,c,d;this.addTimeds.length>0;)this.timedHandlers.push(this.addTimeds.pop());for(;this.removeTimeds.length>0;)b=this.removeTimeds.pop(),a=this.timedHandlers.indexOf(b),a>=0&&this.timedHandlers.splice(a,1);var e=(new Date).getTime();for(d=[],a=0;a<this.timedHandlers.length;a++)b=this.timedHandlers[a],(this.authenticated||!b.user)&&(c=b.lastCalled+b.period,0>=c-e?b.run()&&d.push(b):d.push(b));this.timedHandlers=d,clearTimeout(this._idleTimeout),this._proto._onIdle(),this.connected&&(this._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this),100))}},i.SASLMechanism=function(a,b,c){this.name=a,this.isClientFirst=b,this.priority=c},i.SASLMechanism.prototype={test:function(a){return!0},onStart:function(a){this._connection=a},onChallenge:function(a,b){throw new Error("You should implement challenge handling!")},onFailure:function(){this._connection=null},onSuccess:function(){this._connection=null}},i.SASLAnonymous=function(){},i.SASLAnonymous.prototype=new i.SASLMechanism("ANONYMOUS",!1,10),i.SASLAnonymous.prototype.test=function(a){return null===a.authcid},i.Connection.prototype.mechanisms[i.SASLAnonymous.prototype.name]=i.SASLAnonymous,i.SASLPlain=function(){},i.SASLPlain.prototype=new i.SASLMechanism("PLAIN",!0,20),i.SASLPlain.prototype.test=function(a){return null!==a.authcid},i.SASLPlain.prototype.onChallenge=function(a){var b=a.authzid;return b+="\x00",b+=a.authcid,b+="\x00",b+=a.pass,d.utf16to8(b)},i.Connection.prototype.mechanisms[i.SASLPlain.prototype.name]=i.SASLPlain,i.SASLSHA1=function(){},i.SASLSHA1.prototype=new i.SASLMechanism("SCRAM-SHA-1",!0,40),i.SASLSHA1.prototype.test=function(a){return null!==a.authcid},i.SASLSHA1.prototype.onChallenge=function(e,f,g){var h=g||c.hexdigest(1234567890*Math.random()),i="n="+d.utf16to8(e.authcid);return i+=",r=",i+=h,e._sasl_data.cnonce=h,e._sasl_data["client-first-message-bare"]=i,i="n,,"+i,this.onChallenge=function(c,e){for(var f,g,h,i,j,k,l,m,n,o,p,q,r="c=biws,",s=c._sasl_data["client-first-message-bare"]+","+e+",",t=c._sasl_data.cnonce,u=/([a-z]+)=([^,]+)(,|$)/;e.match(u);){var v=e.match(u);switch(e=e.replace(v[0],""),v[1]){case"r":f=v[2];break;case"s":g=v[2];break;case"i":h=v[2]}}if(f.substr(0,t.length)!==t)return c._sasl_data={},c._sasl_failure_cb();for(r+="r="+f,s+=r,g=b.decode(g),g+="\x00\x00\x00",n=d.utf16to8(c.pass),i=k=a.core_hmac_sha1(n,g),l=1;h>l;l++){for(j=a.core_hmac_sha1(n,a.binb2str(k)),m=0;5>m;m++)i[m]^=j[m];k=j}for(i=a.binb2str(i),o=a.core_hmac_sha1(i,"Client Key"),p=a.str_hmac_sha1(i,"Server Key"),q=a.core_hmac_sha1(a.str_sha1(a.binb2str(o)),s),c._sasl_data["server-signature"]=a.b64_hmac_sha1(p,s),m=0;5>m;m++)o[m]^=q[m];return r+=",p="+b.encode(a.binb2str(o))}.bind(this),i},i.Connection.prototype.mechanisms[i.SASLSHA1.prototype.name]=i.SASLSHA1,i.SASLMD5=function(){},i.SASLMD5.prototype=new i.SASLMechanism("DIGEST-MD5",!1,30),i.SASLMD5.prototype.test=function(a){return null!==a.authcid},i.SASLMD5.prototype._quote=function(a){return'"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'},i.SASLMD5.prototype.onChallenge=function(a,b,e){for(var f,g=/([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/,h=e||c.hexdigest(""+1234567890*Math.random()),i="",j=null,k="",l="";b.match(g);)switch(f=b.match(g),b=b.replace(f[0],""),f[2]=f[2].replace(/^"(.+)"$/,"$1"),f[1]){case"realm":i=f[2];break;case"nonce":k=f[2];break;case"qop":l=f[2];break;case"host":j=f[2]}var m=a.servtype+"/"+a.domain;null!==j&&(m=m+"/"+j);var n=d.utf16to8(a.authcid+":"+i+":"+this._connection.pass),o=c.hash(n)+":"+k+":"+h,p="AUTHENTICATE:"+m,q="";return q+="charset=utf-8,",q+="username="+this._quote(d.utf16to8(a.authcid))+",",q+="realm="+this._quote(i)+",",q+="nonce="+this._quote(k)+",",q+="nc=00000001,",q+="cnonce="+this._quote(h)+",",q+="digest-uri="+this._quote(m)+",",q+="response="+c.hexdigest(c.hexdigest(o)+":"+k+":00000001:"+h+":auth:"+c.hexdigest(p))+",",q+="qop=auth",this.onChallenge=function(){return""},q},i.Connection.prototype.mechanisms[i.SASLMD5.prototype.name]=i.SASLMD5,i.SASLOAuthBearer=function(){},i.SASLOAuthBearer.prototype=new i.SASLMechanism("OAUTHBEARER",!0,50),i.SASLOAuthBearer.prototype.test=function(a){return null!==a.authcid},i.SASLOAuthBearer.prototype.onChallenge=function(a){var b="n,a=";return b+=a.authzid,b+=",",b+="",b+="auth=Bearer ",b+=a.pass,b+="",b+="",d.utf16to8(b)},i.Connection.prototype.mechanisms[i.SASLOAuthBearer.prototype.name]=i.SASLOAuthBearer,i.SASLExternal=function(){},i.SASLExternal.prototype=new i.SASLMechanism("EXTERNAL",!0,60),i.SASLExternal.prototype.onChallenge=function(a){return a.authcid===a.authzid?"":a.authzid},i.Connection.prototype.mechanisms[i.SASLExternal.prototype.name]=i.SASLExternal,{Strophe:i,$build:e,$msg:f,$iq:g,$pres:h,SHA1:a,Base64:b,MD5:c}}),function(a,b){return true?void !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function(a){return b(a.Strophe,a.$build)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):b(Strophe,$build)}(this,function(a,b){return a.Request=function(b,c,d,e){this.id=++a._requestId,this.xmlData=b,this.data=a.serialize(b),this.origFunc=c,this.func=c,this.rid=d,this.date=NaN,this.sends=e||0,this.abort=!1,this.dead=null,this.age=function(){if(!this.date)return 0;var a=new Date;return(a-this.date)/1e3},this.timeDead=function(){if(!this.dead)return 0;var a=new Date;return(a-this.dead)/1e3},this.xhr=this._newXHR()},a.Request.prototype={getResponse:function(){var b=null;if(this.xhr.responseXML&&this.xhr.responseXML.documentElement){if(b=this.xhr.responseXML.documentElement,"parsererror"==b.tagName)throw a.error("invalid response received"),a.error("responseText: "+this.xhr.responseText),a.error("responseXML: "+a.serialize(this.xhr.responseXML)),"parsererror"}else if(this.xhr.responseText)throw a.error("invalid response received"),a.error("responseText: "+this.xhr.responseText),"badformat";return b},_newXHR:function(){var a=null;return window.XMLHttpRequest?(a=new XMLHttpRequest,a.overrideMimeType&&a.overrideMimeType("text/xml; charset=utf-8")):window.ActiveXObject&&(a=new ActiveXObject("Microsoft.XMLHTTP")),a.onreadystatechange=this.func.bind(null,this),a}},a.Bosh=function(a){this._conn=a,this.rid=Math.floor(4294967295*Math.random()),this.sid=null,this.hold=1,this.wait=60,this.window=5,this.errors=0,this._requests=[]},a.Bosh.prototype={strip:null,_buildBody:function(){var c=b("body",{rid:this.rid++,xmlns:a.NS.HTTPBIND});return null!==this.sid&&c.attrs({sid:this.sid}),this._conn.options.keepalive&&this._conn._sessionCachingSupported()&&this._cacheSession(),c},_reset:function(){this.rid=Math.floor(4294967295*Math.random()),this.sid=null,this.errors=0,this._conn._sessionCachingSupported()&&window.sessionStorage.removeItem("strophe-bosh-session"),this._conn.nextValidRid(this.rid)},_connect:function(b,c,d){this.wait=b||this.wait,this.hold=c||this.hold,this.errors=0;var e=this._buildBody().attrs({to:this._conn.domain,"xml:lang":"en",wait:this.wait,hold:this.hold,content:"text/xml; charset=utf-8",ver:"1.6","xmpp:version":"1.0","xmlns:xmpp":a.NS.BOSH});d&&e.attrs({route:d});var f=this._conn._connect_cb;this._requests.push(new a.Request(e.tree(),this._onRequestStateChange.bind(this,f.bind(this._conn)),e.tree().getAttribute("rid"))),this._throttledRequestHandler()},_attach:function(b,c,d,e,f,g,h){this._conn.jid=b,this.sid=c,this.rid=d,this._conn.connect_callback=e,this._conn.domain=a.getDomainFromJid(this._conn.jid),this._conn.authenticated=!0,this._conn.connected=!0,this.wait=f||this.wait,this.hold=g||this.hold,this.window=h||this.window,this._conn._changeConnectStatus(a.Status.ATTACHED,null)},_restore:function(b,c,d,e,f){var g=JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));if(!("undefined"!=typeof g&&null!==g&&g.rid&&g.sid&&g.jid)||"undefined"!=typeof b&&null!==b&&a.getBareJidFromJid(g.jid)!=a.getBareJidFromJid(b))throw{name:"StropheSessionError",message:"_restore: no restoreable session."};this._conn.restored=!0,this._attach(g.jid,g.sid,g.rid,c,d,e,f)},_cacheSession:function(){this._conn.authenticated?this._conn.jid&&this.rid&&this.sid&&window.sessionStorage.setItem("strophe-bosh-session",JSON.stringify({jid:this._conn.jid,rid:this.rid,sid:this.sid})):window.sessionStorage.removeItem("strophe-bosh-session")},_connect_cb:function(b){var c,d,e=b.getAttribute("type");if(null!==e&&"terminate"==e)return c=b.getAttribute("condition"),a.error("BOSH-Connection failed: "+c),d=b.getElementsByTagName("conflict"),null!==c?("remote-stream-error"==c&&d.length>0&&(c="conflict"),this._conn._changeConnectStatus(a.Status.CONNFAIL,c)):this._conn._changeConnectStatus(a.Status.CONNFAIL,"unknown"),this._conn._doDisconnect(c),a.Status.CONNFAIL;this.sid||(this.sid=b.getAttribute("sid"));var f=b.getAttribute("requests");f&&(this.window=parseInt(f,10));var g=b.getAttribute("hold");g&&(this.hold=parseInt(g,10));var h=b.getAttribute("wait");h&&(this.wait=parseInt(h,10))},_disconnect:function(a){this._sendTerminate(a)},_doDisconnect:function(){this.sid=null,this.rid=Math.floor(4294967295*Math.random()),this._conn._sessionCachingSupported()&&window.sessionStorage.removeItem("strophe-bosh-session"),this._conn.nextValidRid(this.rid)},_emptyQueue:function(){return 0===this._requests.length},_hitError:function(b){this.errors++,a.warn("request errored, status: "+b+", number of errors: "+this.errors),this.errors>4&&this._conn._onDisconnectTimeout()},_no_auth_received:function(b){b=b?b.bind(this._conn):this._conn._connect_cb.bind(this._conn);var c=this._buildBody();this._requests.push(new a.Request(c.tree(),this._onRequestStateChange.bind(this,b.bind(this._conn)),c.tree().getAttribute("rid"))),this._throttledRequestHandler()},_onDisconnectTimeout:function(){this._abortAllRequests()},_abortAllRequests:function(){for(var a;this._requests.length>0;)a=this._requests.pop(),a.abort=!0,a.xhr.abort(),a.xhr.onreadystatechange=function(){}},_onIdle:function(){var b=this._conn._data;if(this._conn.authenticated&&0===this._requests.length&&0===b.length&&!this._conn.disconnecting&&(a.info("no requests during idle cycle, sending blank request"),b.push(null)),!this._conn.paused){if(this._requests.length<2&&b.length>0){for(var c=this._buildBody(),d=0;d<b.length;d++)null!==b[d]&&("restart"===b[d]?c.attrs({to:this._conn.domain,"xml:lang":"en","xmpp:restart":"true","xmlns:xmpp":a.NS.BOSH}):c.cnode(b[d]).up());delete this._conn._data,this._conn._data=[],this._requests.push(new a.Request(c.tree(),this._onRequestStateChange.bind(this,this._conn._dataRecv.bind(this._conn)),c.tree().getAttribute("rid"))),this._throttledRequestHandler()}if(this._requests.length>0){var e=this._requests[0].age();null!==this._requests[0].dead&&this._requests[0].timeDead()>Math.floor(a.SECONDARY_TIMEOUT*this.wait)&&this._throttledRequestHandler(),e>Math.floor(a.TIMEOUT*this.wait)&&(a.warn("Request "+this._requests[0].id+" timed out, over "+Math.floor(a.TIMEOUT*this.wait)+" seconds since last activity"),this._throttledRequestHandler())}}},_onRequestStateChange:function(b,c){if(a.debug("request id "+c.id+"."+c.sends+" state changed to "+c.xhr.readyState),c.abort)return void(c.abort=!1);var d;if(4==c.xhr.readyState){d=0;try{d=c.xhr.status}catch(e){}if("undefined"==typeof d&&(d=0),this.disconnecting&&d>=400)return void this._hitError(d);var f=this._requests[0]==c,g=this._requests[1]==c;(d>0&&500>d||c.sends>5)&&(this._removeRequest(c),a.debug("request id "+c.id+" should now be removed")),200==d?((g||f&&this._requests.length>0&&this._requests[0].age()>Math.floor(a.SECONDARY_TIMEOUT*this.wait))&&this._restartRequest(0),this._conn.nextValidRid(Number(c.rid)+1),a.debug("request id "+c.id+"."+c.sends+" got 200"),b(c),this.errors=0):(a.error("request id "+c.id+"."+c.sends+" error "+d+" happened"),(0===d||d>=400&&600>d||d>=12e3)&&(this._hitError(d),d>=400&&500>d&&(this._conn._changeConnectStatus(a.Status.DISCONNECTING,null),this._conn._doDisconnect()))),d>0&&500>d||c.sends>5||this._throttledRequestHandler()}},_processRequest:function(b){var c=this,d=this._requests[b],e=-1;try{4==d.xhr.readyState&&(e=d.xhr.status)}catch(f){a.error("caught an error in _requests["+b+"], reqStatus: "+e)}if("undefined"==typeof e&&(e=-1),d.sends>this._conn.maxRetries)return void this._conn._onDisconnectTimeout();var g=d.age(),h=!isNaN(g)&&g>Math.floor(a.TIMEOUT*this.wait),i=null!==d.dead&&d.timeDead()>Math.floor(a.SECONDARY_TIMEOUT*this.wait),j=4==d.xhr.readyState&&(1>e||e>=500);if((h||i||j)&&(i&&a.error("Request "+this._requests[b].id+" timed out (secondary), restarting"),d.abort=!0,d.xhr.abort(),d.xhr.onreadystatechange=function(){},this._requests[b]=new a.Request(d.xmlData,d.origFunc,d.rid,d.sends),d=this._requests[b]),0===d.xhr.readyState){a.debug("request id "+d.id+"."+d.sends+" posting");try{var k=this._conn.options.contentType||"text/xml; charset=utf-8";d.xhr.open("POST",this._conn.service,this._conn.options.sync?!1:!0),d.xhr.setRequestHeader&&d.xhr.setRequestHeader("Content-Type",k),this._conn.options.withCredentials&&(d.xhr.withCredentials=!0)}catch(l){return a.error("XHR open failed."),this._conn.connected||this._conn._changeConnectStatus(a.Status.CONNFAIL,"bad-service"),void this._conn.disconnect()}var m=function(){if(d.date=new Date,c._conn.options.customHeaders){var a=c._conn.options.customHeaders;for(var b in a)a.hasOwnProperty(b)&&d.xhr.setRequestHeader(b,a[b])}d.xhr.send(d.data)};if(d.sends>1){var n=1e3*Math.min(Math.floor(a.TIMEOUT*this.wait),Math.pow(d.sends,3));setTimeout(function(){m()},n)}else m();d.sends++,this._conn.xmlOutput!==a.Connection.prototype.xmlOutput&&(d.xmlData.nodeName===this.strip&&d.xmlData.childNodes.length?this._conn.xmlOutput(d.xmlData.childNodes[0]):this._conn.xmlOutput(d.xmlData)),this._conn.rawOutput!==a.Connection.prototype.rawOutput&&this._conn.rawOutput(d.data)}else a.debug("_processRequest: "+(0===b?"first":"second")+" request has readyState of "+d.xhr.readyState)},_removeRequest:function(b){a.debug("removing request");var c;for(c=this._requests.length-1;c>=0;c--)b==this._requests[c]&&this._requests.splice(c,1);b.xhr.onreadystatechange=function(){},this._throttledRequestHandler()},_restartRequest:function(a){var b=this._requests[a];null===b.dead&&(b.dead=new Date),this._processRequest(a)},_reqToData:function(a){try{return a.getResponse()}catch(b){if("parsererror"!=b)throw b;this._conn.disconnect("strophe-parsererror")}},_sendTerminate:function(b){a.info("_sendTerminate was called");var c=this._buildBody().attrs({type:"terminate"});b&&c.cnode(b.tree());var d=new a.Request(c.tree(),this._onRequestStateChange.bind(this,this._conn._dataRecv.bind(this._conn)),c.tree().getAttribute("rid"));this._requests.push(d),this._throttledRequestHandler()},_send:function(){clearTimeout(this._conn._idleTimeout),this._throttledRequestHandler(),this._conn._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this._conn),100)},_sendRestart:function(){this._throttledRequestHandler(),clearTimeout(this._conn._idleTimeout)},_throttledRequestHandler:function(){this._requests?a.debug("_throttledRequestHandler called with "+this._requests.length+" requests"):a.debug("_throttledRequestHandler called with undefined requests"),this._requests&&0!==this._requests.length&&(this._requests.length>0&&this._processRequest(0),this._requests.length>1&&Math.abs(this._requests[0].rid-this._requests[1].rid)<this.window&&this._processRequest(1))}},a}),function(a,b){return true?void !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_7__ = (function(a){return b(a.Strophe,a.$build)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):b(Strophe,$build)}(this,function(a,b){return a.Websocket=function(a){this._conn=a,this.strip="wrapper";var b=a.service;if(0!==b.indexOf("ws:")&&0!==b.indexOf("wss:")){var c="";c+="ws"===a.options.protocol&&"https:"!==window.location.protocol?"ws":"wss",c+="://"+window.location.host,c+=0!==b.indexOf("/")?window.location.pathname+b:b,a.service=c}},a.Websocket.prototype={_buildStream:function(){return b("open",{xmlns:a.NS.FRAMING,to:this._conn.domain,version:"1.0"})},_check_streamerror:function(b,c){var d;if(d=b.getElementsByTagNameNS?b.getElementsByTagNameNS(a.NS.STREAM,"error"):b.getElementsByTagName("stream:error"),0===d.length)return!1;for(var e=d[0],f="",g="",h="urn:ietf:params:xml:ns:xmpp-streams",i=0;i<e.childNodes.length;i++){var j=e.childNodes[i];if(j.getAttribute("xmlns")!==h)break;"text"===j.nodeName?g=j.textContent:f=j.nodeName}var k="WebSocket stream error: ";return k+=f?f:"unknown",g&&(k+=" - "+f),a.error(k),this._conn._changeConnectStatus(c,f),this._conn._doDisconnect(),!0},_reset:function(){},_connect:function(){this._closeSocket(),this.socket=new WebSocket(this._conn.service,"xmpp"),this.socket.onopen=this._onOpen.bind(this),this.socket.onerror=this._onError.bind(this),this.socket.onclose=this._onClose.bind(this),this.socket.onmessage=this._connect_cb_wrapper.bind(this)},_connect_cb:function(b){var c=this._check_streamerror(b,a.Status.CONNFAIL);return c?a.Status.CONNFAIL:void 0},_handleStreamStart:function(b){var c=!1,d=b.getAttribute("xmlns");"string"!=typeof d?c="Missing xmlns in <open />":d!==a.NS.FRAMING&&(c="Wrong xmlns in <open />: "+d);var e=b.getAttribute("version");return"string"!=typeof e?c="Missing version in <open />":"1.0"!==e&&(c="Wrong version in <open />: "+e),c?(this._conn._changeConnectStatus(a.Status.CONNFAIL,c),this._conn._doDisconnect(),!1):!0},_connect_cb_wrapper:function(b){if(0===b.data.indexOf("<open ")||0===b.data.indexOf("<?xml")){var c=b.data.replace(/^(<\?.*?\?>\s*)*/,"");if(""===c)return;var d=(new DOMParser).parseFromString(c,"text/xml").documentElement;this._conn.xmlInput(d),this._conn.rawInput(b.data),this._handleStreamStart(d)&&this._connect_cb(d)}else if(0===b.data.indexOf("<close ")){this._conn.rawInput(b.data),this._conn.xmlInput(b);var e=b.getAttribute("see-other-uri");e?(this._conn._changeConnectStatus(a.Status.REDIRECT,"Received see-other-uri, resetting connection"),this._conn.reset(),this._conn.service=e,this._connect()):(this._conn._changeConnectStatus(a.Status.CONNFAIL,"Received closing stream"),this._conn._doDisconnect())}else{var f=this._streamWrap(b.data),g=(new DOMParser).parseFromString(f,"text/xml").documentElement;this.socket.onmessage=this._onMessage.bind(this),this._conn._connect_cb(g,null,b.data)}},_disconnect:function(c){if(this.socket&&this.socket.readyState!==WebSocket.CLOSED){c&&this._conn.send(c);var d=b("close",{xmlns:a.NS.FRAMING});this._conn.xmlOutput(d);var e=a.serialize(d);this._conn.rawOutput(e);try{this.socket.send(e)}catch(f){a.info("Couldn't send <close /> tag.")}}this._conn._doDisconnect()},_doDisconnect:function(){a.info("WebSockets _doDisconnect was called"),this._closeSocket()},_streamWrap:function(a){return"<wrapper>"+a+"</wrapper>"},_closeSocket:function(){if(this.socket)try{this.socket.close()}catch(a){}this.socket=null},_emptyQueue:function(){return!0},_onClose:function(){this._conn.connected&&!this._conn.disconnecting?(a.error("Websocket closed unexpectedly"),this._conn._doDisconnect()):a.info("Websocket closed")},_no_auth_received:function(b){a.error("Server did not send any auth methods"),this._conn._changeConnectStatus(a.Status.CONNFAIL,"Server did not send any auth methods"),b&&(b=b.bind(this._conn))(),this._conn._doDisconnect()},_onDisconnectTimeout:function(){},_abortAllRequests:function(){},_onError:function(b){a.error("Websocket error "+b),this._conn._changeConnectStatus(a.Status.CONNFAIL,"The WebSocket connection could not be established or was disconnected."),this._disconnect()},_onIdle:function(){var b=this._conn._data;if(b.length>0&&!this._conn.paused){for(var c=0;c<b.length;c++)if(null!==b[c]){var d,e;d="restart"===b[c]?this._buildStream().tree():b[c],e=a.serialize(d),this._conn.xmlOutput(d),this._conn.rawOutput(e),this.socket.send(e)}this._conn._data=[]}},_onMessage:function(b){var c,d,e='<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';if(b.data===e)return this._conn.rawInput(e),this._conn.xmlInput(b),void(this._conn.disconnecting||this._conn._doDisconnect());if(0===b.data.search("<open ")){if(c=(new DOMParser).parseFromString(b.data,"text/xml").documentElement,!this._handleStreamStart(c))return}else d=this._streamWrap(b.data),c=(new DOMParser).parseFromString(d,"text/xml").documentElement;return this._check_streamerror(c,a.Status.ERROR)?void 0:this._conn.disconnecting&&"presence"===c.firstChild.nodeName&&"unavailable"===c.firstChild.getAttribute("type")?(this._conn.xmlInput(c),void this._conn.rawInput(a.serialize(c))):void this._conn._dataRecv(c,b.data)},_onOpen:function(){a.info("Websocket open");var b=this._buildStream();this._conn.xmlOutput(b.tree());var c=a.serialize(b);this._conn.rawOutput(c),this.socket.send(c)},_reqToData:function(a){return a},_send:function(){this._conn.flush()},_sendRestart:function(){clearTimeout(this._conn._idleTimeout),this._conn._onIdle.bind(this._conn)()}},a}),function(a){"function"=="function"&&__webpack_require__(122)&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__,__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_7__], __WEBPACK_LOCAL_MODULE_8__ = (function(a){return a}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))}(this),a){if(false)return a(Strophe,$build,$msg,$iq,$pres);var b=a;"function"==typeof requirejs?requirejs(["strophe"],function(a){b(a.Strophe,a.$build,a.$msg,a.$iq,a.$pres)}):!/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__]; (function(a){b(a.Strophe,a.$build,a.$msg,a.$iq,a.$pres)}.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}())}}(function(a,b,c,d,e){window.Strophe=a,window.$build=b,window.$msg=c,window.$iq=d,window.$pres=e});

/***/ },

/***/ 122:
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },

/***/ 123:
/***/ function(module, exports) {

	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "./";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ({

	/***/ 0:
	/***/ function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(230);


	/***/ },

	/***/ 223:
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

		;
		(function () {

		    var EMPTYFN = function EMPTYFN() {};
		    var _code = __webpack_require__(224).code;
		    var WEBIM_FILESIZE_LIMIT = 10485760;

		    var _createStandardXHR = function _createStandardXHR() {
		        try {
		            return new window.XMLHttpRequest();
		        } catch (e) {
		            return false;
		        }
		    };

		    var _createActiveXHR = function _createActiveXHR() {
		        try {
		            return new window.ActiveXObject('Microsoft.XMLHTTP');
		        } catch (e) {
		            return false;
		        }
		    };

		    var _xmlrequest = function _xmlrequest(crossDomain) {
		        crossDomain = crossDomain || true;
		        var temp = _createStandardXHR() || _createActiveXHR();

		        if ('withCredentials' in temp) {
		            return temp;
		        }
		        if (!crossDomain) {
		            return temp;
		        }
		        if (typeof window.XDomainRequest === 'undefined') {
		            return temp;
		        }
		        var xhr = new XDomainRequest();
		        xhr.readyState = 0;
		        xhr.status = 100;
		        xhr.onreadystatechange = EMPTYFN;
		        xhr.onload = function () {
		            xhr.readyState = 4;
		            xhr.status = 200;

		            var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
		            xmlDoc.async = 'false';
		            xmlDoc.loadXML(xhr.responseText);
		            xhr.responseXML = xmlDoc;
		            xhr.response = xhr.responseText;
		            xhr.onreadystatechange();
		        };
		        xhr.ontimeout = xhr.onerror = function () {
		            xhr.readyState = 4;
		            xhr.status = 500;
		            xhr.onreadystatechange();
		        };
		        return xhr;
		    };

		    var _hasFlash = function () {
		        if ('ActiveXObject' in window) {
		            try {
		                return new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
		            } catch (ex) {
		                return 0;
		            }
		        } else {
		            if (navigator.plugins && navigator.plugins.length > 0) {
		                return navigator.plugins['Shockwave Flash'];
		            }
		        }
		        return 0;
		    }();

		    var _base64 = function _base64() {

		        var self = this;

		        // private property
		        var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

		        // public method for encoding
		        this.encode = function (input) {
		            var output = "";
		            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		            var i = 0;
		            input = self._utf8_encode(input);
		            while (i < input.length) {
		                chr1 = input.charCodeAt(i++);
		                chr2 = input.charCodeAt(i++);
		                chr3 = input.charCodeAt(i++);
		                enc1 = chr1 >> 2;
		                enc2 = (chr1 & 3) << 4 | chr2 >> 4;
		                enc3 = (chr2 & 15) << 2 | chr3 >> 6;
		                enc4 = chr3 & 63;
		                if (isNaN(chr2)) {
		                    enc3 = enc4 = 64;
		                } else if (isNaN(chr3)) {
		                    enc4 = 64;
		                }
		                output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
		            }
		            return output;
		        };

		        // public method for decoding
		        this.decode = function (input) {
		            var output = "";
		            var chr1, chr2, chr3;
		            var enc1, enc2, enc3, enc4;
		            var i = 0;
		            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
		            while (i < input.length) {
		                enc1 = _keyStr.indexOf(input.charAt(i++));
		                enc2 = _keyStr.indexOf(input.charAt(i++));
		                enc3 = _keyStr.indexOf(input.charAt(i++));
		                enc4 = _keyStr.indexOf(input.charAt(i++));
		                chr1 = enc1 << 2 | enc2 >> 4;
		                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
		                chr3 = (enc3 & 3) << 6 | enc4;
		                output = output + String.fromCharCode(chr1);
		                if (enc3 != 64) {
		                    output = output + String.fromCharCode(chr2);
		                }
		                if (enc4 != 64) {
		                    output = output + String.fromCharCode(chr3);
		                }
		            }
		            output = self._utf8_decode(output);
		            return output;
		        };

		        // private method for UTF-8 encoding
		        this._utf8_encode = function (string) {
		            string = string.replace(/\r\n/g, "\n");
		            var utftext = "";
		            for (var n = 0; n < string.length; n++) {
		                var c = string.charCodeAt(n);
		                if (c < 128) {
		                    utftext += String.fromCharCode(c);
		                } else if (c > 127 && c < 2048) {
		                    utftext += String.fromCharCode(c >> 6 | 192);
		                    utftext += String.fromCharCode(c & 63 | 128);
		                } else {
		                    utftext += String.fromCharCode(c >> 12 | 224);
		                    utftext += String.fromCharCode(c >> 6 & 63 | 128);
		                    utftext += String.fromCharCode(c & 63 | 128);
		                }
		            }
		            return utftext;
		        };

		        // private method for UTF-8 decoding
		        this._utf8_decode = function (utftext) {
		            var string = "";
		            var i = 0;
		            var c = 0;
		            var c1 = 0;
		            var c2 = 0;
		            var c3 = 0;
		            while (i < utftext.length) {
		                c = utftext.charCodeAt(i);
		                if (c < 128) {
		                    string += String.fromCharCode(c);
		                    i++;
		                } else if (c > 191 && c < 224) {
		                    c2 = utftext.charCodeAt(i + 1);
		                    string += String.fromCharCode((c & 31) << 6 | c2 & 63);
		                    i += 2;
		                } else {
		                    c2 = utftext.charCodeAt(i + 1);
		                    c3 = utftext.charCodeAt(i + 2);
		                    string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
		                    i += 3;
		                }
		            }
		            return string;
		        };
		    };

		    var _tmpUtilXHR = _xmlrequest(),
		        _hasFormData = typeof FormData !== 'undefined',
		        _hasBlob = typeof Blob !== 'undefined',
		        _isCanSetRequestHeader = _tmpUtilXHR.setRequestHeader || false,
		        _hasOverrideMimeType = _tmpUtilXHR.overrideMimeType || false,
		        _isCanUploadFileAsync = _isCanSetRequestHeader && _hasFormData,
		        _isCanUploadFile = _isCanUploadFileAsync || _hasFlash,
		        _isCanDownLoadFile = _isCanSetRequestHeader && (_hasBlob || _hasOverrideMimeType);

		    if (!Object.keys) {
		        Object.keys = function () {
		            'use strict';

		            var hasOwnProperty = Object.prototype.hasOwnProperty,
		                hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
		                dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
		                dontEnumsLength = dontEnums.length;

		            return function (obj) {
		                if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof obj !== 'function' || obj === null)) {
		                    throw new TypeError('Object.keys called on non-object');
		                }

		                var result = [],
		                    prop,
		                    i;

		                for (prop in obj) {
		                    if (hasOwnProperty.call(obj, prop)) {
		                        result.push(prop);
		                    }
		                }

		                if (hasDontEnumBug) {
		                    for (i = 0; i < dontEnumsLength; i++) {
		                        if (hasOwnProperty.call(obj, dontEnums[i])) {
		                            result.push(dontEnums[i]);
		                        }
		                    }
		                }
		                return result;
		            };
		        }();
		    }

		    var utils = {
		        hasFormData: _hasFormData,

		        hasBlob: _hasBlob,

		        emptyfn: EMPTYFN,

		        isCanSetRequestHeader: _isCanSetRequestHeader,

		        hasOverrideMimeType: _hasOverrideMimeType,

		        isCanUploadFileAsync: _isCanUploadFileAsync,

		        isCanUploadFile: _isCanUploadFile,

		        isCanDownLoadFile: _isCanDownLoadFile,

		        isSupportWss: function () {
		            var notSupportList = [
		            //1: QQ browser X5 core
		            /MQQBrowser[\/]5([.]\d+)?\sTBS/

		            //2: etc.
		            //...
		            ];

		            if (!window.WebSocket) {
		                return false;
		            }

		            var ua = window.navigator.userAgent;
		            for (var i = 0, l = notSupportList.length; i < l; i++) {
		                if (notSupportList[i].test(ua)) {
		                    return false;
		                }
		            }
		            return true;
		        }(),

		        getIEVersion: function () {
		            var ua = navigator.userAgent,
		                matches,
		                tridentMap = { '4': 8, '5': 9, '6': 10, '7': 11 };

		            matches = ua.match(/MSIE (\d+)/i);

		            if (matches && matches[1]) {
		                return +matches[1];
		            }
		            matches = ua.match(/Trident\/(\d+)/i);
		            if (matches && matches[1]) {
		                return tridentMap[matches[1]] || null;
		            }
		            return null;
		        }(),

		        stringify: function stringify(json) {
		            if (typeof JSON !== 'undefined' && JSON.stringify) {
		                return JSON.stringify(json);
		            } else {
		                var s = '',
		                    arr = [];

		                var iterate = function iterate(json) {
		                    var isArr = false;

		                    if (Object.prototype.toString.call(json) === '[object Array]') {
		                        arr.push(']', '[');
		                        isArr = true;
		                    } else if (Object.prototype.toString.call(json) === '[object Object]') {
		                        arr.push('}', '{');
		                    }

		                    for (var o in json) {
		                        if (Object.prototype.toString.call(json[o]) === '[object Null]') {
		                            json[o] = 'null';
		                        } else if (Object.prototype.toString.call(json[o]) === '[object Undefined]') {
		                            json[o] = 'undefined';
		                        }

		                        if (json[o] && _typeof(json[o]) === 'object') {
		                            s += ',' + (isArr ? '' : '"' + o + '":' + (isArr ? '"' : '')) + iterate(json[o]) + '';
		                        } else {
		                            s += ',"' + (isArr ? '' : o + '":"') + json[o] + '"';
		                        }
		                    }

		                    if (s != '') {
		                        s = s.slice(1);
		                    }

		                    return arr.pop() + s + arr.pop();
		                };
		                return iterate(json);
		            }
		        },
		        login: function login(options) {
		            var options = options || {};
		            var suc = options.success || EMPTYFN;
		            var err = options.error || EMPTYFN;

		            var appKey = options.appKey || '';
		            var devInfos = appKey.split('#');
		            if (devInfos.length !== 2) {
		                err({
		                    type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR
		                });
		                return false;
		            }

		            var orgName = devInfos[0];
		            var appName = devInfos[1];
		            var https = https || options.https;
		            var user = options.user || '';
		            var pwd = options.pwd || '';

		            var apiUrl = options.apiUrl;

		            var loginJson = {
		                grant_type: 'password',
		                username: user,
		                password: pwd,
		                timestamp: +new Date()
		            };
		            var loginfo = utils.stringify(loginJson);

		            var options = {
		                url: apiUrl + '/' + orgName + '/' + appName + '/token',
		                dataType: 'json',
		                data: loginfo,
		                success: suc,
		                error: err
		            };
		            return utils.ajax(options);
		        },

		        getFileUrl: function getFileUrl(fileInputId) {
		            var uri = {
		                url: '',
		                filename: '',
		                filetype: '',
		                data: ''
		            };

		            var fileObj = typeof fileInputId === 'string' ? document.getElementById(fileInputId) : fileInputId;

		            if (!utils.isCanUploadFileAsync || !fileObj) {
		                return uri;
		            }
		            try {
		                if (window.URL.createObjectURL) {
		                    var fileItems = fileObj.files;
		                    if (fileItems.length > 0) {
		                        var u = fileItems.item(0);
		                        uri.data = u;
		                        uri.url = window.URL.createObjectURL(u);
		                        uri.filename = u.name || '';
		                    }
		                } else {
		                    // IE
		                    var u = document.getElementById(fileInputId).value;
		                    uri.url = u;
		                    var pos1 = u.lastIndexOf('/');
		                    var pos2 = u.lastIndexOf('\\');
		                    var pos = Math.max(pos1, pos2);
		                    if (pos < 0) uri.filename = u;else uri.filename = u.substring(pos + 1);
		                }
		                var index = uri.filename.lastIndexOf('.');
		                if (index != -1) {
		                    uri.filetype = uri.filename.substring(index + 1).toLowerCase();
		                }
		                return uri;
		            } catch (e) {
		                throw e;
		            }
		        },

		        getFileSize: function getFileSize(file) {
		            var fileSize = 0;
		            if (file) {
		                if (file.files) {
		                    if (file.files.length > 0) {
		                        fileSize = file.files[0].size;
		                    }
		                } else if (file.select && 'ActiveXObject' in window) {
		                    file.select();
		                    var fileobject = new ActiveXObject('Scripting.FileSystemObject');
		                    var file = fileobject.GetFile(file.value);
		                    fileSize = file.Size;
		                }
		            }
		            console.log('fileSize: ', fileSize);
		            if (fileSize > 10000000) {
		                return false;
		            }
		            var kb = Math.round(fileSize / 1000);
		            if (kb < 1000) {
		                fileSize = kb + ' KB';
		            } else if (kb >= 1000) {
		                var mb = kb / 1000;
		                if (mb < 1000) {
		                    fileSize = mb.toFixed(1) + ' MB';
		                } else {
		                    var gb = mb / 1000;
		                    fileSize = gb.toFixed(1) + ' GB';
		                }
		            }
		            return fileSize;
		        },

		        hasFlash: _hasFlash,

		        trim: function trim(str) {

		            str = typeof str === 'string' ? str : '';

		            return str.trim ? str.trim() : str.replace(/^\s|\s$/g, '');
		        },

		        parseEmoji: function parseEmoji(msg) {
		            if (typeof WebIM.Emoji === 'undefined' || typeof WebIM.Emoji.map === 'undefined') {
		                return msg;
		            } else {
		                var emoji = WebIM.Emoji,
		                    reg = null;

		                for (var face in emoji.map) {
		                    if (emoji.map.hasOwnProperty(face)) {
		                        while (msg.indexOf(face) > -1) {
		                            msg = msg.replace(face, '<img class="emoji" src="' + emoji.path + emoji.map[face] + '" />');
		                        }
		                    }
		                }
		                return msg;
		            }
		        },

		        parseLink: function parseLink(msg) {

		            var reg = /(https?\:\/\/|www\.)([a-zA-Z0-9-]+(\.[a-zA-Z0-9]+)+)(\:[0-9]{2,4})?\/?((\.[:_0-9a-zA-Z-]+)|[:_0-9a-zA-Z-]*\/?)*\??[:_#@*&%0-9a-zA-Z-/=]*/gm;

		            msg = msg.replace(reg, function (v) {

		                var prefix = /^https?/gm.test(v);

		                return "<a href='" + (prefix ? v : '//' + v) + "' target='_blank'>" + v + "</a>";
		            });

		            return msg;
		        },

		        parseJSON: function parseJSON(data) {

		            if (window.JSON && window.JSON.parse) {
		                return window.JSON.parse(data + '');
		            }

		            var requireNonComma,
		                depth = null,
		                str = utils.trim(data + '');

		            return str && !utils.trim(str.replace(/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g, function (token, comma, open, close) {

		                if (requireNonComma && comma) {
		                    depth = 0;
		                }

		                if (depth === 0) {
		                    return token;
		                }

		                requireNonComma = open || comma;
		                depth += !close - !open;
		                return '';
		            })) ? Function('return ' + str)() : Function('Invalid JSON: ' + data)();
		        },

		        parseUploadResponse: function parseUploadResponse(response) {
		            return response.indexOf('callback') > -1 ? //lte ie9
		            response.slice(9, -1) : response;
		        },

		        parseDownloadResponse: function parseDownloadResponse(response) {
		            return response && response.type && response.type === 'application/json' || 0 > Object.prototype.toString.call(response).indexOf('Blob') ? this.url + '?token=' : window.URL.createObjectURL(response);
		        },

		        uploadFile: function uploadFile(options) {
		            var options = options || {};
		            options.onFileUploadProgress = options.onFileUploadProgress || EMPTYFN;
		            options.onFileUploadComplete = options.onFileUploadComplete || EMPTYFN;
		            options.onFileUploadError = options.onFileUploadError || EMPTYFN;
		            options.onFileUploadCanceled = options.onFileUploadCanceled || EMPTYFN;

		            var acc = options.accessToken || this.context.accessToken;
		            if (!acc) {
		                options.onFileUploadError({
		                    type: _code.WEBIM_UPLOADFILE_NO_LOGIN,
		                    id: options.id
		                });
		                return;
		            }

		            var orgName, appName, devInfos;
		            var appKey = options.appKey || this.context.appKey || '';

		            if (appKey) {
		                devInfos = appKey.split('#');
		                orgName = devInfos[0];
		                appName = devInfos[1];
		            }

		            if (!orgName && !appName) {
		                options.onFileUploadError({
		                    type: _code.WEBIM_UPLOADFILE_ERROR,
		                    id: options.id
		                });
		                return;
		            }

		            var apiUrl = options.apiUrl;
		            var uploadUrl = apiUrl + '/' + orgName + '/' + appName + '/chatfiles';

		            if (!utils.isCanUploadFileAsync) {
		                if (utils.hasFlash && typeof options.flashUpload === 'function') {
		                    options.flashUpload && options.flashUpload(uploadUrl, options);
		                } else {
		                    options.onFileUploadError({
		                        type: _code.WEBIM_UPLOADFILE_BROWSER_ERROR,
		                        id: options.id
		                    });
		                }
		                return;
		            }

		            var fileSize = options.file.data ? options.file.data.size : undefined;
		            if (fileSize > WEBIM_FILESIZE_LIMIT) {
		                options.onFileUploadError({
		                    type: _code.WEBIM_UPLOADFILE_ERROR,
		                    id: options.id
		                });
		                return;
		            } else if (fileSize <= 0) {
		                options.onFileUploadError({
		                    type: _code.WEBIM_UPLOADFILE_ERROR,
		                    id: options.id
		                });
		                return;
		            }

		            var xhr = utils.xmlrequest();
		            var onError = function onError(e) {
		                options.onFileUploadError({
		                    type: _code.WEBIM_UPLOADFILE_ERROR,
		                    id: options.id,
		                    xhr: xhr
		                });
		            };
		            if (xhr.upload) {
		                xhr.upload.addEventListener('progress', options.onFileUploadProgress, false);
		            }
		            if (xhr.addEventListener) {
		                xhr.addEventListener('abort', options.onFileUploadCanceled, false);
		                xhr.addEventListener('load', function (e) {
		                    try {
		                        var json = utils.parseJSON(xhr.responseText);
		                        try {
		                            options.onFileUploadComplete(json);
		                        } catch (e) {
		                            options.onFileUploadError({
		                                type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR,
		                                data: e
		                            });
		                        }
		                    } catch (e) {
		                        options.onFileUploadError({
		                            type: _code.WEBIM_UPLOADFILE_ERROR,
		                            data: xhr.responseText,
		                            id: options.id,
		                            xhr: xhr
		                        });
		                    }
		                }, false);
		                xhr.addEventListener('error', onError, false);
		            } else if (xhr.onreadystatechange) {
		                xhr.onreadystatechange = function () {
		                    if (xhr.readyState === 4) {
		                        if (ajax.status === 200) {
		                            try {
		                                var json = utils.parseJSON(xhr.responseText);
		                                options.onFileUploadComplete(json);
		                            } catch (e) {
		                                options.onFileUploadError({
		                                    type: _code.WEBIM_UPLOADFILE_ERROR,
		                                    data: xhr.responseText,
		                                    id: options.id,
		                                    xhr: xhr
		                                });
		                            }
		                        } else {
		                            options.onFileUploadError({
		                                type: _code.WEBIM_UPLOADFILE_ERROR,
		                                data: xhr.responseText,
		                                id: options.id,
		                                xhr: xhr
		                            });
		                        }
		                    } else {
		                        xhr.abort();
		                        options.onFileUploadCanceled();
		                    }
		                };
		            }

		            xhr.open('POST', uploadUrl);

		            xhr.setRequestHeader('restrict-access', 'true');
		            xhr.setRequestHeader('Accept', '*/*'); // Android QQ browser has some problem with this attribute.
		            xhr.setRequestHeader('Authorization', 'Bearer ' + acc);

		            var formData = new FormData();
		            formData.append('file', options.file.data);
		            xhr.send(formData);
		        },

		        download: function download(options) {
		            options.onFileDownloadComplete = options.onFileDownloadComplete || EMPTYFN;
		            options.onFileDownloadError = options.onFileDownloadError || EMPTYFN;

		            var accessToken = options.accessToken || this.context.accessToken;
		            if (!accessToken) {
		                options.onFileDownloadError({
		                    type: _code.WEBIM_DOWNLOADFILE_NO_LOGIN,
		                    id: options.id
		                });
		                return;
		            }

		            var onError = function onError(e) {
		                options.onFileDownloadError({
		                    type: _code.WEBIM_DOWNLOADFILE_ERROR,
		                    id: options.id,
		                    xhr: xhr
		                });
		            };

		            if (!utils.isCanDownLoadFile) {
		                options.onFileDownloadComplete();
		                return;
		            }
		            var xhr = utils.xmlrequest();
		            if ('addEventListener' in xhr) {
		                xhr.addEventListener('load', function (e) {
		                    options.onFileDownloadComplete(xhr.response, xhr);
		                }, false);
		                xhr.addEventListener('error', onError, false);
		            } else if ('onreadystatechange' in xhr) {
		                xhr.onreadystatechange = function () {
		                    if (xhr.readyState === 4) {
		                        if (ajax.status === 200) {
		                            options.onFileDownloadComplete(xhr.response, xhr);
		                        } else {
		                            options.onFileDownloadError({
		                                type: _code.WEBIM_DOWNLOADFILE_ERROR,
		                                id: options.id,
		                                xhr: xhr
		                            });
		                        }
		                    } else {
		                        xhr.abort();
		                        options.onFileDownloadError({
		                            type: _code.WEBIM_DOWNLOADFILE_ERROR,
		                            id: options.id,
		                            xhr: xhr
		                        });
		                    }
		                };
		            }

		            var method = options.method || 'GET';
		            var resType = options.responseType || 'blob';
		            var mimeType = options.mimeType || 'text/plain; charset=x-user-defined';
		            xhr.open(method, options.url);
		            if (typeof Blob !== 'undefined') {
		                xhr.responseType = resType;
		            } else {
		                xhr.overrideMimeType(mimeType);
		            }

		            var innerHeaer = {
		                'X-Requested-With': 'XMLHttpRequest',
		                'Accept': 'application/octet-stream',
		                'share-secret': options.secret,
		                'Authorization': 'Bearer ' + accessToken
		            };
		            var headers = options.headers || {};
		            for (var key in headers) {
		                innerHeaer[key] = headers[key];
		            }
		            for (var key in innerHeaer) {
		                if (innerHeaer[key]) {
		                    xhr.setRequestHeader(key, innerHeaer[key]);
		                }
		            }
		            xhr.send(null);
		        },

		        parseTextMessage: function parseTextMessage(message, faces) {
		            if (typeof message !== 'string') {
		                return;
		            }

		            if (Object.prototype.toString.call(faces) !== '[object Object]') {
		                return {
		                    isemoji: false,
		                    body: [{
		                        type: 'txt',
		                        data: message
		                    }]
		                };
		            }

		            var receiveMsg = message;
		            var emessage = [];
		            var expr = /\[[^[\]]{2,3}\]/mg;
		            var emoji = receiveMsg.match(expr);

		            if (!emoji || emoji.length < 1) {
		                return {
		                    isemoji: false,
		                    body: [{
		                        type: 'txt',
		                        data: message
		                    }]
		                };
		            }
		            var isemoji = false;
		            for (var i = 0; i < emoji.length; i++) {
		                var tmsg = receiveMsg.substring(0, receiveMsg.indexOf(emoji[i])),
		                    existEmoji = WebIM.Emoji.map[emoji[i]];

		                if (tmsg) {
		                    emessage.push({
		                        type: 'txt',
		                        data: tmsg
		                    });
		                }
		                if (!existEmoji) {
		                    emessage.push({
		                        type: 'txt',
		                        data: emoji[i]
		                    });
		                    continue;
		                }
		                var emojiStr = WebIM.Emoji.map ? WebIM.Emoji.path + existEmoji : null;

		                if (emojiStr) {
		                    isemoji = true;
		                    emessage.push({
		                        type: 'emoji',
		                        data: emojiStr
		                    });
		                } else {
		                    emessage.push({
		                        type: 'txt',
		                        data: emoji[i]
		                    });
		                }
		                var restMsgIndex = receiveMsg.indexOf(emoji[i]) + emoji[i].length;
		                receiveMsg = receiveMsg.substring(restMsgIndex);
		            }
		            if (receiveMsg) {
		                emessage.push({
		                    type: 'txt',
		                    data: receiveMsg
		                });
		            }
		            if (isemoji) {
		                return {
		                    isemoji: isemoji,
		                    body: emessage
		                };
		            }
		            return {
		                isemoji: false,
		                body: [{
		                    type: 'txt',
		                    data: message
		                }]
		            };
		        },

		        xmlrequest: _xmlrequest,

		        getXmlFirstChild: function getXmlFirstChild(data, tagName) {
		            var children = data.getElementsByTagName(tagName);
		            if (children.length == 0) {
		                return null;
		            } else {
		                return children[0];
		            }
		        },
		        ajax: function ajax(options) {
		            var dataType = options.dataType || 'text';
		            var suc = options.success || EMPTYFN;
		            var error = options.error || EMPTYFN;
		            var xhr = utils.xmlrequest();

		            xhr.onreadystatechange = function () {
		                if (xhr.readyState === 4) {
		                    var status = xhr.status || 0;
		                    if (status === 200) {
		                        try {
		                            switch (dataType) {
		                                case 'text':
		                                    suc(xhr.responseText);
		                                    return;
		                                case 'json':
		                                    var json = utils.parseJSON(xhr.responseText);
		                                    suc(json, xhr);
		                                    return;
		                                case 'xml':
		                                    if (xhr.responseXML && xhr.responseXML.documentElement) {
		                                        suc(xhr.responseXML.documentElement, xhr);
		                                    } else {
		                                        error({
		                                            type: _code.WEBIM_CONNCTION_AJAX_ERROR,
		                                            data: xhr.responseText
		                                        });
		                                    }
		                                    return;
		                            }
		                            suc(xhr.response || xhr.responseText, xhr);
		                        } catch (e) {
		                            error({
		                                type: _code.WEBIM_CONNCTION_AJAX_ERROR,
		                                data: e
		                            });
		                        }
		                        return;
		                    } else {
		                        error({
		                            type: _code.WEBIM_CONNCTION_AJAX_ERROR,
		                            data: xhr.responseText
		                        });
		                        return;
		                    }
		                }
		                if (xhr.readyState === 0) {
		                    error({
		                        type: _code.WEBIM_CONNCTION_AJAX_ERROR,
		                        data: xhr.responseText
		                    });
		                }
		            };

		            if (options.responseType) {
		                if (xhr.responseType) {
		                    xhr.responseType = options.responseType;
		                }
		            }
		            if (options.mimeType) {
		                if (utils.hasOverrideMimeType) {
		                    xhr.overrideMimeType(options.mimeType);
		                }
		            }

		            var type = options.type || 'POST',
		                data = options.data || null,
		                tempData = '';

		            if (type.toLowerCase() === 'get' && data) {
		                for (var o in data) {
		                    if (data.hasOwnProperty(o)) {
		                        tempData += o + '=' + data[o] + '&';
		                    }
		                }
		                tempData = tempData ? tempData.slice(0, -1) : tempData;
		                options.url += (options.url.indexOf('?') > 0 ? '&' : '?') + (tempData ? tempData + '&' : tempData) + '_v=' + new Date().getTime();
		                data = null;
		                tempData = null;
		            }
		            xhr.open(type, options.url);

		            if (utils.isCanSetRequestHeader) {
		                var headers = options.headers || {};
		                for (var key in headers) {
		                    if (headers.hasOwnProperty(key)) {
		                        xhr.setRequestHeader(key, headers[key]);
		                    }
		                }
		            }

		            xhr.send(data);
		            return xhr;
		        },
		        ts: function ts() {
		            var d = new Date();
		            var Hours = d.getHours(); //获取当前小时数(0-23)
		            var Minutes = d.getMinutes(); //获取当前分钟数(0-59)
		            var Seconds = d.getSeconds(); //获取当前秒数(0-59)
		            var Milliseconds = d.getMilliseconds(); //获取当前毫秒
		            return (Hours < 10 ? "0" + Hours : Hours) + ':' + (Minutes < 10 ? "0" + Minutes : Minutes) + ':' + (Seconds < 10 ? "0" + Seconds : Seconds) + ':' + Milliseconds + ' ';
		        },

		        getObjectKey: function getObjectKey(obj, val) {
		            for (var key in obj) {
		                if (obj[key] == val) {
		                    return key;
		                }
		            }
		            return '';
		        },

		        sprintf: function sprintf() {
		            var arg = arguments,
		                str = arg[0] || '',
		                i,
		                len;
		            for (i = 1, len = arg.length; i < len; i++) {
		                str = str.replace(/%s/, arg[i]);
		            }
		            return str;
		        },

		        encrypt: function encrypt(str) {
		            var base64 = new _base64();
		            var encrypt = base64.encode(str);
		            return encrypt;
		        },

		        decrypt: function decrypt(str) {
		            var base64 = new _base64();
		            var decrypt = base64.decode(str);
		            decrypt = escape(decrypt);
		            decrypt = decrypt.replace(/%00/g, '');
		            decrypt = unescape(decrypt);
		            return decrypt;
		        },

		        setCookie: function setCookie(name, value, days) {
		            var cookie = name + '=' + encodeURIComponent(value);
		            if (typeof days == 'number') {
		                cookie += '; max-age: ' + days * 60 * 60 * 24;
		            }
		            document.cookie = cookie;
		        },

		        getCookie: function getCookie() {
		            var allCookie = {};
		            var all = document.cookie;
		            if (all === "") {
		                return allCookie;
		            }
		            var list = all.split("; ");
		            for (var i = 0; i < list.length; i++) {
		                var cookie = list[i];
		                var p = cookie.indexOf('=');
		                var name = cookie.substring(0, p);
		                var value = cookie.substring(p + 1);
		                value = decodeURIComponent(value);
		                allCookie[name] = value;
		            }
		            return allCookie;
		        }
		    };

		    exports.utils = utils;
		})();

	/***/ },

	/***/ 224:
	/***/ function(module, exports) {

		"use strict";

		;
		(function () {

		    exports.code = {
		        WEBIM_CONNCTION_USER_NOT_ASSIGN_ERROR: 0,
		        WEBIM_CONNCTION_OPEN_ERROR: 1,
		        WEBIM_CONNCTION_AUTH_ERROR: 2,
		        WEBIM_CONNCTION_OPEN_USERGRID_ERROR: 3,
		        WEBIM_CONNCTION_ATTACH_ERROR: 4,
		        WEBIM_CONNCTION_ATTACH_USERGRID_ERROR: 5,
		        WEBIM_CONNCTION_REOPEN_ERROR: 6,
		        WEBIM_CONNCTION_SERVER_CLOSE_ERROR: 7, //7: client-side network offline (net::ERR_INTERNET_DISCONNECTED)
		        WEBIM_CONNCTION_SERVER_ERROR: 8, //8: offline by multi login
		        WEBIM_CONNCTION_IQ_ERROR: 9,

		        WEBIM_CONNCTION_PING_ERROR: 10,
		        WEBIM_CONNCTION_NOTIFYVERSION_ERROR: 11,
		        WEBIM_CONNCTION_GETROSTER_ERROR: 12,
		        WEBIM_CONNCTION_CROSSDOMAIN_ERROR: 13,
		        WEBIM_CONNCTION_LISTENING_OUTOF_MAXRETRIES: 14,
		        WEBIM_CONNCTION_RECEIVEMSG_CONTENTERROR: 15,
		        WEBIM_CONNCTION_DISCONNECTED: 16, //16: server-side close the websocket connection
		        WEBIM_CONNCTION_AJAX_ERROR: 17,
		        WEBIM_CONNCTION_JOINROOM_ERROR: 18,
		        WEBIM_CONNCTION_GETROOM_ERROR: 19,

		        WEBIM_CONNCTION_GETROOMINFO_ERROR: 20,
		        WEBIM_CONNCTION_GETROOMMEMBER_ERROR: 21,
		        WEBIM_CONNCTION_GETROOMOCCUPANTS_ERROR: 22,
		        WEBIM_CONNCTION_LOAD_CHATROOM_ERROR: 23,
		        WEBIM_CONNCTION_NOT_SUPPORT_CHATROOM_ERROR: 24,
		        WEBIM_CONNCTION_JOINCHATROOM_ERROR: 25,
		        WEBIM_CONNCTION_QUITCHATROOM_ERROR: 26,
		        WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR: 27,
		        WEBIM_CONNCTION_TOKEN_NOT_ASSIGN_ERROR: 28,
		        WEBIM_CONNCTION_SESSIONID_NOT_ASSIGN_ERROR: 29,

		        WEBIM_CONNCTION_RID_NOT_ASSIGN_ERROR: 30,
		        WEBIM_CONNCTION_CALLBACK_INNER_ERROR: 31,
		        WEBIM_CONNCTION_CLIENT_OFFLINE: 32, //32: client offline
		        WEBIM_CONNCTION_CLIENT_LOGOUT: 33, //33: client logout
		        WEBIM_CONNCTION_CLIENT_TOO_MUCH_ERROR: 34, // Over amount of the tabs a user opened in the same browser
		        WEBIM_CONNECTION_ACCEPT_INVITATION_FROM_GROUP: 35,
		        WEBIM_CONNECTION_DECLINE_INVITATION_FROM_GROUP: 36,
		        WEBIM_CONNECTION_ACCEPT_JOIN_GROUP: 37,
		        WEBIM_CONNECTION_DECLINE_JOIN_GROUP: 38,
		        WEBIM_CONNECTION_CLOSED: 39,

		        WEBIM_UPLOADFILE_BROWSER_ERROR: 100,
		        WEBIM_UPLOADFILE_ERROR: 101,
		        WEBIM_UPLOADFILE_NO_LOGIN: 102,
		        WEBIM_UPLOADFILE_NO_FILE: 103,

		        WEBIM_DOWNLOADFILE_ERROR: 200,
		        WEBIM_DOWNLOADFILE_NO_LOGIN: 201,
		        WEBIM_DOWNLOADFILE_BROWSER_ERROR: 202,

		        WEBIM_MESSAGE_REC_TEXT: 300,
		        WEBIM_MESSAGE_REC_TEXT_ERROR: 301,
		        WEBIM_MESSAGE_REC_EMOTION: 302,
		        WEBIM_MESSAGE_REC_PHOTO: 303,
		        WEBIM_MESSAGE_REC_AUDIO: 304,
		        WEBIM_MESSAGE_REC_AUDIO_FILE: 305,
		        WEBIM_MESSAGE_REC_VEDIO: 306,
		        WEBIM_MESSAGE_REC_VEDIO_FILE: 307,
		        WEBIM_MESSAGE_REC_FILE: 308,
		        WEBIM_MESSAGE_SED_TEXT: 309,
		        WEBIM_MESSAGE_SED_EMOTION: 310,
		        WEBIM_MESSAGE_SED_PHOTO: 311,
		        WEBIM_MESSAGE_SED_AUDIO: 312,
		        WEBIM_MESSAGE_SED_AUDIO_FILE: 313,
		        WEBIM_MESSAGE_SED_VEDIO: 314,
		        WEBIM_MESSAGE_SED_VEDIO_FILE: 315,
		        WEBIM_MESSAGE_SED_FILE: 316,
		        WEBIM_MESSAGE_SED_ERROR: 317,

		        STATUS_INIT: 400,
		        STATUS_DOLOGIN_USERGRID: 401,
		        STATUS_DOLOGIN_IM: 402,
		        STATUS_OPENED: 403,
		        STATUS_CLOSING: 404,
		        STATUS_CLOSED: 405,
		        STATUS_ERROR: 406
		    };
		})();

	/***/ },

	/***/ 230:
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		module.exports = __webpack_require__(231);

	/***/ },

	/***/ 231:
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _version = '1.4.2';
		var _code = __webpack_require__(224).code;
		var _utils = __webpack_require__(223).utils;
		var _msg = __webpack_require__(232);
		var _message = _msg._msg;
		var _msgHash = {};
		var Queue = __webpack_require__(233).Queue;

		window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

		if (window.XDomainRequest) {
		    XDomainRequest.prototype.oldsend = XDomainRequest.prototype.send;
		    XDomainRequest.prototype.send = function () {
		        XDomainRequest.prototype.oldsend.apply(this, arguments);
		        this.readyState = 2;
		    };
		}

		Strophe.Request.prototype._newXHR = function () {
		    var xhr = _utils.xmlrequest(true);
		    if (xhr.overrideMimeType) {
		        xhr.overrideMimeType('text/xml');
		    }
		    // use Function.bind() to prepend ourselves as an argument
		    xhr.onreadystatechange = this.func.bind(null, this);
		    return xhr;
		};

		Strophe.Websocket.prototype._closeSocket = function () {
		    if (this.socket) {
		        var me = this;
		        setTimeout(function () {
		            try {
		                me.socket.close();
		            } catch (e) {}
		        }, 0);
		    } else {
		        this.socket = null;
		    }
		};

		/**
		 *
		 * Strophe.Websocket has a bug while logout:
		 * 1.send: <presence xmlns='jabber:client' type='unavailable'/> is ok;
		 * 2.send: <close xmlns='urn:ietf:params:xml:ns:xmpp-framing'/> will cause a problem,log as follows:
		 * WebSocket connection to 'ws://im-api.easemob.com/ws/' failed: Data frame received after close_connect @ strophe.js:5292connect @ strophe.js:2491_login @ websdk-1.1.2.js:278suc @ websdk-1.1.2.js:636xhr.onreadystatechange @ websdk-1.1.2.js:2582
		 * 3 "Websocket error [object Event]"
		 * _changeConnectStatus
		 * onError Object {type: 7, msg: "The WebSocket connection could not be established or was disconnected.", reconnect: true}
		 *
		 * this will trigger socket.onError, therefore _doDisconnect again.
		 * Fix it by overide  _onMessage
		 */
		Strophe.Websocket.prototype._onMessage = function (message) {
		    WebIM && WebIM.config.isDebug && console.log(WebIM.utils.ts() + 'recv:', message.data);
		    var elem, data;
		    // check for closing stream
		    // var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
		    // if (message.data === close) {
		    //     this._conn.rawInput(close);
		    //     this._conn.xmlInput(message);
		    //     if (!this._conn.disconnecting) {
		    //         this._conn._doDisconnect();
		    //     }
		    //     return;
		    //
		    // send and receive close xml: <close xmlns='urn:ietf:params:xml:ns:xmpp-framing'/>
		    // so we can't judge whether message.data equals close by === simply.
		    if (message.data.indexOf("<close ") === 0) {
		        elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
		        var see_uri = elem.getAttribute("see-other-uri");
		        if (see_uri) {
		            this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
		            this._conn.reset();
		            this._conn.service = see_uri;
		            this._connect();
		        } else {
		            // if (!this._conn.disconnecting) {
		            this._conn._doDisconnect("receive <close> from server");
		            // }
		        }
		        return;
		    } else if (message.data.search("<open ") === 0) {
		        // This handles stream restarts
		        elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
		        if (!this._handleStreamStart(elem)) {
		            return;
		        }
		    } else {
		        data = this._streamWrap(message.data);
		        elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
		    }

		    if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
		        return;
		    }

		    //handle unavailable presence stanza before disconnecting
		    if (this._conn.disconnecting && elem.firstChild.nodeName === "presence" && elem.firstChild.getAttribute("type") === "unavailable") {
		        this._conn.xmlInput(elem);
		        this._conn.rawInput(Strophe.serialize(elem));
		        // if we are already disconnecting we will ignore the unavailable stanza and
		        // wait for the </stream:stream> tag before we close the connection
		        return;
		    }
		    this._conn._dataRecv(elem, message.data);
		};

		var _listenNetwork = function _listenNetwork(onlineCallback, offlineCallback) {

		    if (window.addEventListener) {
		        window.addEventListener('online', onlineCallback);
		        window.addEventListener('offline', offlineCallback);
		    } else if (window.attachEvent) {
		        if (document.body) {
		            document.body.attachEvent('ononline', onlineCallback);
		            document.body.attachEvent('onoffline', offlineCallback);
		        } else {
		            window.attachEvent('load', function () {
		                document.body.attachEvent('ononline', onlineCallback);
		                document.body.attachEvent('onoffline', offlineCallback);
		            });
		        }
		    } else {
		        /*var onlineTmp = window.ononline;
		         var offlineTmp = window.onoffline;
		          window.attachEvent('ononline', function () {
		         try {
		         typeof onlineTmp === 'function' && onlineTmp();
		         } catch ( e ) {}
		         onlineCallback();
		         });
		         window.attachEvent('onoffline', function () {
		         try {
		         typeof offlineTmp === 'function' && offlineTmp();
		         } catch ( e ) {}
		         offlineCallback();
		         });*/
		    }
		};

		var _parseRoom = function _parseRoom(result) {
		    var rooms = [];
		    var items = result.getElementsByTagName('item');
		    if (items) {
		        for (var i = 0; i < items.length; i++) {
		            var item = items[i];
		            var roomJid = item.getAttribute('jid');
		            var tmp = roomJid.split('@')[0];
		            var room = {
		                jid: roomJid,
		                name: item.getAttribute('name'),
		                roomId: tmp.split('_')[1]
		            };
		            rooms.push(room);
		        }
		    }
		    return rooms;
		};

		var _parseRoomOccupants = function _parseRoomOccupants(result) {
		    var occupants = [];
		    var items = result.getElementsByTagName('item');
		    if (items) {
		        for (var i = 0; i < items.length; i++) {
		            var item = items[i];
		            var room = {
		                jid: item.getAttribute('jid'),
		                name: item.getAttribute('name')
		            };
		            occupants.push(room);
		        }
		    }
		    return occupants;
		};

		var _parseResponseMessage = function _parseResponseMessage(msginfo) {
		    var parseMsgData = { errorMsg: true, data: [] };

		    var msgBodies = msginfo.getElementsByTagName('body');
		    if (msgBodies) {
		        for (var i = 0; i < msgBodies.length; i++) {
		            var msgBody = msgBodies[i];
		            var childNodes = msgBody.childNodes;
		            if (childNodes && childNodes.length > 0) {
		                var childNode = msgBody.childNodes[0];
		                if (childNode.nodeType == Strophe.ElementType.TEXT) {
		                    var jsondata = childNode.wholeText || childNode.nodeValue;
		                    jsondata = jsondata.replace('\n', '<br>');
		                    try {
		                        var data = eval('(' + jsondata + ')');
		                        parseMsgData.errorMsg = false;
		                        parseMsgData.data = [data];
		                    } catch (e) {}
		                }
		            }
		        }

		        var delayTags = msginfo.getElementsByTagName('delay');
		        if (delayTags && delayTags.length > 0) {
		            var delayTag = delayTags[0];
		            var delayMsgTime = delayTag.getAttribute('stamp');
		            if (delayMsgTime) {
		                parseMsgData.delayTimeStamp = delayMsgTime;
		            }
		        }
		    } else {
		        var childrens = msginfo.childNodes;
		        if (childrens && childrens.length > 0) {
		            var child = msginfo.childNodes[0];
		            if (child.nodeType == Strophe.ElementType.TEXT) {
		                try {
		                    var data = eval('(' + child.nodeValue + ')');
		                    parseMsgData.errorMsg = false;
		                    parseMsgData.data = [data];
		                } catch (e) {}
		            }
		        }
		    }
		    return parseMsgData;
		};

		var _parseNameFromJidFn = function _parseNameFromJidFn(jid, domain) {
		    domain = domain || '';
		    var tempstr = jid;
		    var findex = tempstr.indexOf('_');

		    if (findex !== -1) {
		        tempstr = tempstr.substring(findex + 1);
		    }
		    var atindex = tempstr.indexOf('@' + domain);
		    if (atindex !== -1) {
		        tempstr = tempstr.substring(0, atindex);
		    }
		    return tempstr;
		};

		var _parseFriend = function _parseFriend(queryTag, conn, from) {
		    var rouster = [];
		    var items = queryTag.getElementsByTagName('item');
		    if (items) {
		        for (var i = 0; i < items.length; i++) {
		            var item = items[i];
		            var jid = item.getAttribute('jid');
		            if (!jid) {
		                continue;
		            }
		            var subscription = item.getAttribute('subscription');
		            var friend = {
		                subscription: subscription,
		                jid: jid
		            };
		            var ask = item.getAttribute('ask');
		            if (ask) {
		                friend.ask = ask;
		            }
		            var name = item.getAttribute('name');
		            if (name) {
		                friend.name = name;
		            } else {
		                var n = _parseNameFromJidFn(jid);
		                friend.name = n;
		            }
		            var groups = [];
		            Strophe.forEachChild(item, 'group', function (group) {
		                groups.push(Strophe.getText(group));
		            });
		            friend.groups = groups;
		            rouster.push(friend);
		            // B同意之后 -> B订阅A
		            if (conn && subscription == 'from') {
		                conn.subscribe({
		                    toJid: jid
		                });
		            }

		            if (conn && subscription == 'to') {
		                conn.subscribed({
		                    toJid: jid
		                });
		            }
		        }
		    }
		    return rouster;
		};

		var _login = function _login(options, conn) {
		    var accessToken = options.access_token || '';
		    if (accessToken == '') {
		        var loginfo = _utils.stringify(options);
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_OPEN_USERGRID_ERROR,
		            data: options
		        });
		        return;
		    }
		    conn.context.accessToken = options.access_token;
		    conn.context.accessTokenExpires = options.expires_in;
		    var stropheConn = null;
		    if (conn.isOpening() && conn.context.stropheConn) {
		        stropheConn = conn.context.stropheConn;
		    } else if (conn.isOpened() && conn.context.stropheConn) {
		        // return;
		        stropheConn = conn.getStrophe();
		    } else {
		        stropheConn = conn.getStrophe();
		    }
		    var callback = function callback(status, msg) {
		        _loginCallback(status, msg, conn);
		    };

		    conn.context.stropheConn = stropheConn;
		    if (conn.route) {
		        stropheConn.connect(conn.context.jid, '$t$' + accessToken, callback, conn.wait, conn.hold, conn.route);
		    } else {
		        stropheConn.connect(conn.context.jid, '$t$' + accessToken, callback, conn.wait, conn.hold);
		    }
		};

		var _parseMessageType = function _parseMessageType(msginfo) {
		    var msgtype = 'normal';
		    var receiveinfo = msginfo.getElementsByTagName('received');
		    if (receiveinfo && receiveinfo.length > 0 && receiveinfo[0].namespaceURI === 'urn:xmpp:receipts') {
		        msgtype = 'received';
		    } else {
		        var inviteinfo = msginfo.getElementsByTagName('invite');
		        if (inviteinfo && inviteinfo.length > 0) {
		            msgtype = 'invite';
		        }
		    }
		    return msgtype;
		};

		var _handleMessageQueue = function _handleMessageQueue(conn) {
		    for (var i in _msgHash) {
		        if (_msgHash.hasOwnProperty(i)) {
		            _msgHash[i].send(conn);
		        }
		    }
		};

		var _loginCallback = function _loginCallback(status, msg, conn) {
		    var conflict, error;

		    if (msg === 'conflict') {
		        conflict = true;
		    }

		    if (status == Strophe.Status.CONNFAIL) {
		        //client offline, ping/pong timeout, server quit, server offline
		        error = {
		            type: _code.WEBIM_CONNCTION_SERVER_CLOSE_ERROR,
		            msg: msg,
		            reconnect: true
		        };

		        conflict && (error.conflict = true);
		        conn.onError(error);
		    } else if (status == Strophe.Status.ATTACHED || status == Strophe.Status.CONNECTED) {
		        // client should limit the speed of sending ack messages  up to 5/s
		        conn.autoReconnectNumTotal = 0;
		        conn.intervalId = setInterval(function () {
		            conn.handelSendQueue();
		        }, 200);
		        var handleMessage = function handleMessage(msginfo) {
		            var type = _parseMessageType(msginfo);

		            if ('received' === type) {
		                conn.handleReceivedMessage(msginfo);
		                return true;
		            } else if ('invite' === type) {
		                conn.handleInviteMessage(msginfo);
		                return true;
		            } else {
		                conn.handleMessage(msginfo);
		                return true;
		            }
		        };
		        var handlePresence = function handlePresence(msginfo) {
		            conn.handlePresence(msginfo);
		            return true;
		        };
		        var handlePing = function handlePing(msginfo) {
		            conn.handlePing(msginfo);
		            return true;
		        };
		        var handleIqRoster = function handleIqRoster(msginfo) {
		            conn.handleIqRoster(msginfo);
		            return true;
		        };
		        var handleIqPrivacy = function handleIqPrivacy(msginfo) {
		            conn.handleIqPrivacy(msginfo);
		            return true;
		        };
		        var handleIq = function handleIq(msginfo) {
		            conn.handleIq(msginfo);
		            return true;
		        };

		        conn.addHandler(handleMessage, null, 'message', null, null, null);
		        conn.addHandler(handlePresence, null, 'presence', null, null, null);
		        conn.addHandler(handlePing, 'urn:xmpp:ping', 'iq', 'get', null, null);
		        conn.addHandler(handleIqRoster, 'jabber:iq:roster', 'iq', 'set', null, null);
		        conn.addHandler(handleIqPrivacy, 'jabber:iq:privacy', 'iq', 'set', null, null);
		        conn.addHandler(handleIq, null, 'iq', null, null, null);

		        conn.context.status = _code.STATUS_OPENED;

		        var supportRecMessage = [_code.WEBIM_MESSAGE_REC_TEXT, _code.WEBIM_MESSAGE_REC_EMOJI];

		        if (_utils.isCanDownLoadFile) {
		            supportRecMessage.push(_code.WEBIM_MESSAGE_REC_PHOTO);
		            supportRecMessage.push(_code.WEBIM_MESSAGE_REC_AUDIO_FILE);
		        }
		        var supportSedMessage = [_code.WEBIM_MESSAGE_SED_TEXT];
		        if (_utils.isCanUploadFile) {
		            supportSedMessage.push(_code.WEBIM_MESSAGE_REC_PHOTO);
		            supportSedMessage.push(_code.WEBIM_MESSAGE_REC_AUDIO_FILE);
		        }
		        conn.notifyVersion();
		        conn.retry && _handleMessageQueue(conn);
		        conn.heartBeat();
		        conn.isAutoLogin && conn.setPresence();
		        conn.onOpened({
		            canReceive: supportRecMessage,
		            canSend: supportSedMessage,
		            accessToken: conn.context.accessToken
		        });
		    } else if (status == Strophe.Status.DISCONNECTING) {
		        if (conn.isOpened()) {
		            conn.stopHeartBeat();
		            conn.context.status = _code.STATUS_CLOSING;

		            error = {
		                type: _code.WEBIM_CONNCTION_SERVER_CLOSE_ERROR,
		                msg: msg,
		                reconnect: true
		            };

		            conflict && (error.conflict = true);
		            conn.onError(error);
		        }
		    } else if (status == Strophe.Status.DISCONNECTED) {
		        if (conn.isOpened()) {
		            if (conn.autoReconnectNumTotal < conn.autoReconnectNumMax) {
		                conn.reconnect();
		                return;
		            } else {
		                error = {
		                    type: _code.WEBIM_CONNCTION_DISCONNECTED
		                };
		                conn.onError(error);
		            }
		        }
		        conn.context.status = _code.STATUS_CLOSED;
		        conn.clear();
		        conn.onClosed();
		    } else if (status == Strophe.Status.AUTHFAIL) {
		        error = {
		            type: _code.WEBIM_CONNCTION_AUTH_ERROR
		        };

		        conflict && (error.conflict = true);
		        conn.onError(error);
		        conn.clear();
		    } else if (status == Strophe.Status.ERROR) {
		        conn.context.status = _code.STATUS_ERROR;
		        error = {
		            type: _code.WEBIM_CONNCTION_SERVER_ERROR
		        };

		        conflict && (error.conflict = true);
		        conn.onError(error);
		    }
		    conn.context.status_now = status;
		};

		var _getJid = function _getJid(options, conn) {
		    var jid = options.toJid || '';

		    if (jid === '') {
		        var appKey = conn.context.appKey || '';
		        var toJid = appKey + '_' + options.to + '@' + conn.domain;

		        if (options.resource) {
		            toJid = toJid + '/' + options.resource;
		        }
		        jid = toJid;
		    }
		    return jid;
		};

		var _getJidByName = function _getJidByName(name, conn) {
		    var options = {
		        to: name
		    };
		    return _getJid(options, conn);
		};

		var _validCheck = function _validCheck(options, conn) {
		    options = options || {};

		    if (options.user == '') {
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_USER_NOT_ASSIGN_ERROR
		        });
		        return false;
		    }

		    var user = options.user + '' || '';
		    var appKey = options.appKey || '';
		    var devInfos = appKey.split('#');

		    if (devInfos.length !== 2) {
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR
		        });
		        return false;
		    }
		    var orgName = devInfos[0];
		    var appName = devInfos[1];

		    if (!orgName) {
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR
		        });
		        return false;
		    }
		    if (!appName) {
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR
		        });
		        return false;
		    }

		    var jid = appKey + '_' + user.toLowerCase() + '@' + conn.domain,
		        resource = options.resource || 'webim';

		    if (conn.isMultiLoginSessions) {
		        resource += user + new Date().getTime() + Math.floor(Math.random().toFixed(6) * 1000000);
		    }
		    conn.context.jid = jid + '/' + resource;
		    /*jid: {appkey}_{username}@domain/resource*/
		    conn.context.userId = user;
		    conn.context.appKey = appKey;
		    conn.context.appName = appName;
		    conn.context.orgName = orgName;

		    return true;
		};

		var _getXmppUrl = function _getXmppUrl(baseUrl, https) {
		    if (/^(ws|http)s?:\/\/?/.test(baseUrl)) {
		        return baseUrl;
		    }

		    var url = {
		        prefix: 'http',
		        base: '://' + baseUrl,
		        suffix: '/http-bind/'
		    };

		    if (https && _utils.isSupportWss) {
		        url.prefix = 'wss';
		        url.suffix = '/ws/';
		    } else {
		        if (https) {
		            url.prefix = 'https';
		        } else if (window.WebSocket) {
		            url.prefix = 'ws';
		            url.suffix = '/ws/';
		        }
		    }

		    return url.prefix + url.base + url.suffix;
		};

		//class
		var connection = function connection(options) {
		    if (!this instanceof connection) {
		        return new connection(options);
		    }

		    var options = options || {};

		    this.isHttpDNS = options.isHttpDNS || false;
		    this.isMultiLoginSessions = options.isMultiLoginSessions || false;
		    this.wait = options.wait || 30;
		    this.retry = options.retry || false;
		    this.https = options.https || location.protocol === 'https:';
		    this.url = _getXmppUrl(options.url, this.https);
		    this.hold = options.hold || 1;
		    this.route = options.route || null;
		    this.domain = options.domain || 'easemob.com';
		    this.inactivity = options.inactivity || 30;
		    this.heartBeatWait = options.heartBeatWait || 4500;
		    this.maxRetries = options.maxRetries || 5;
		    this.isAutoLogin = options.isAutoLogin === false ? false : true;
		    this.pollingTime = options.pollingTime || 800;
		    this.stropheConn = false;
		    this.autoReconnectNumMax = options.autoReconnectNumMax || 0;
		    this.autoReconnectNumTotal = 0;
		    this.autoReconnectInterval = options.autoReconnectInterval || 0;
		    this.context = { status: _code.STATUS_INIT };
		    this.sendQueue = new Queue(); //instead of sending message immediately,cache them in this queue
		    this.intervalId = null; //clearInterval return value
		    this.apiUrl = options.apiUrl || '';
		    this.isWindowSDK = options.isWindowSDK || false;

		    this.dnsArr = ['https://rs.easemob.com', 'https://rsbak.easemob.com', 'http://182.92.174.78', 'http://112.126.66.111']; //http dns server hosts
		    this.dnsIndex = 0; //the dns ip used in dnsArr currently
		    this.dnsTotal = this.dnsArr.length; //max number of getting dns retries
		    this.restHosts = null; //rest server ips
		    this.restIndex = 0; //the rest ip used in restHosts currently
		    this.restTotal = 0; //max number of getting rest token retries
		    this.xmppHosts = null; //xmpp server ips
		    this.xmppIndex = 0; //the xmpp ip used in xmppHosts currently
		    this.xmppTotal = 0; //max number of creating xmpp server connection(ws/bosh) retries

		    this.groupOption = {};
		};

		connection.prototype.registerUser = function (options) {
		    if (location.protocol != 'https:' && this.isHttpDNS) {
		        this.dnsIndex = 0;
		        this.getHttpDNS(options, 'signup');
		    } else {
		        this.signup(options);
		    }
		};

		connection.prototype.handelSendQueue = function () {
		    var options = this.sendQueue.pop();
		    if (options !== null) {
		        this.sendReceiptsMessage(options);
		    }
		};
		connection.prototype.listen = function (options) {
		    this.onOpened = options.onOpened || _utils.emptyfn;
		    this.onClosed = options.onClosed || _utils.emptyfn;
		    this.onTextMessage = options.onTextMessage || _utils.emptyfn;
		    this.onEmojiMessage = options.onEmojiMessage || _utils.emptyfn;
		    this.onPictureMessage = options.onPictureMessage || _utils.emptyfn;
		    this.onAudioMessage = options.onAudioMessage || _utils.emptyfn;
		    this.onVideoMessage = options.onVideoMessage || _utils.emptyfn;
		    this.onFileMessage = options.onFileMessage || _utils.emptyfn;
		    this.onLocationMessage = options.onLocationMessage || _utils.emptyfn;
		    this.onCmdMessage = options.onCmdMessage || _utils.emptyfn;
		    this.onPresence = options.onPresence || _utils.emptyfn;
		    this.onRoster = options.onRoster || _utils.emptyfn;
		    this.onError = options.onError || _utils.emptyfn;
		    this.onReceivedMessage = options.onReceivedMessage || _utils.emptyfn;
		    this.onInviteMessage = options.onInviteMessage || _utils.emptyfn;
		    this.onOffline = options.onOffline || _utils.emptyfn;
		    this.onOnline = options.onOnline || _utils.emptyfn;
		    this.onConfirmPop = options.onConfirmPop || _utils.emptyfn;
		    //for WindowSDK start
		    this.onUpdateMyGroupList = options.onUpdateMyGroupList || _utils.emptyfn;
		    this.onUpdateMyRoster = options.onUpdateMyRoster || _utils.emptyfn;
		    //for WindowSDK end
		    this.onBlacklistUpdate = options.onBlacklistUpdate || _utils.emptyfn;

		    _listenNetwork(this.onOnline, this.onOffline);
		};

		connection.prototype.heartBeat = function () {
		    var me = this;
		    //IE8: strophe auto switch from ws to BOSH, need heartbeat
		    var isNeed = !/^ws|wss/.test(me.url) || /mobile/.test(navigator.userAgent);

		    if (this.heartBeatID || !isNeed) {
		        return;
		    }

		    var options = {
		        toJid: this.domain,
		        type: 'normal'
		    };
		    this.heartBeatID = setInterval(function () {
		        me.ping(options);
		    }, this.heartBeatWait);
		};

		connection.prototype.stopHeartBeat = function () {
		    if (typeof this.heartBeatID == "number") {
		        this.heartBeatID = clearInterval(this.heartBeatID);
		    }
		};

		connection.prototype.sendReceiptsMessage = function (options) {
		    var dom = $msg({
		        from: this.context.jid || '',
		        to: this.domain,
		        id: options.id || ''
		    }).c('received', {
		        xmlns: 'urn:xmpp:receipts',
		        id: options.id || ''
		    });
		    this.sendCommand(dom.tree());
		};

		connection.prototype.cacheReceiptsMessage = function (options) {
		    this.sendQueue.push(options);
		};

		connection.prototype.getStrophe = function () {
		    if (location.protocol != 'https:' && this.isHttpDNS) {
		        //TODO: try this.xmppTotal times on fail
		        var url = '';
		        var host = this.xmppHosts[this.xmppIndex];
		        var domain = _utils.getXmlFirstChild(host, 'domain');
		        var ip = _utils.getXmlFirstChild(host, 'ip');
		        if (ip) {
		            url = ip.textContent;
		            var port = _utils.getXmlFirstChild(host, 'port');
		            if (port.textContent != '80') {
		                url += ':' + port.textContent;
		            }
		        } else {
		            url = domain.textContent;
		        }

		        if (url != '') {
		            var parter = /(.+\/\/).+(\/.+)/;
		            this.url = this.url.replace(parter, "$1" + url + "$2");
		        }
		    }

		    var stropheConn = new Strophe.Connection(this.url, {
		        inactivity: this.inactivity,
		        maxRetries: this.maxRetries,
		        pollingTime: this.pollingTime
		    });
		    return stropheConn;
		};
		connection.prototype.getHostsByTag = function (data, tagName) {
		    var tag = _utils.getXmlFirstChild(data, tagName);
		    if (!tag) {
		        console.log(tagName + ' hosts error');
		        return null;
		    }
		    var hosts = tag.getElementsByTagName('hosts');
		    if (hosts.length == 0) {
		        console.log(tagName + ' hosts error2');
		        return null;
		    }
		    return hosts[0].getElementsByTagName('host');
		};
		connection.prototype.getRestFromHttpDNS = function (options, type) {
		    if (this.restIndex > this.restTotal) {
		        console.log('rest hosts all tried,quit');
		        return;
		    }
		    var url = '';
		    var host = this.restHosts[this.restIndex];
		    var domain = _utils.getXmlFirstChild(host, 'domain');
		    var ip = _utils.getXmlFirstChild(host, 'ip');
		    if (ip) {
		        var port = _utils.getXmlFirstChild(host, 'port');
		        url = (location.protocol === 'https:' ? 'https:' : 'http:') + '//' + ip.textContent + ':' + port.textContent;
		    } else {
		        url = (location.protocol === 'https:' ? 'https:' : 'http:') + '//' + domain.textContent;
		    }

		    if (url != '') {
		        this.apiUrl = url;
		        options.apiUrl = url;
		    }

		    if (type == 'login') {
		        this.login(options);
		    } else {
		        this.signup(options);
		    }
		};

		connection.prototype.getHttpDNS = function (options, type) {
		    if (this.restHosts) {
		        this.getRestFromHttpDNS(options, type);
		        return;
		    }
		    var self = this;
		    var suc = function suc(data, xhr) {
		        data = new DOMParser().parseFromString(data, "text/xml").documentElement;
		        //get rest ips
		        var restHosts = self.getHostsByTag(data, 'rest');
		        if (!restHosts) {
		            console.log('rest hosts error3');
		            return;
		        }
		        self.restHosts = restHosts;
		        self.restTotal = restHosts.length;

		        //get xmpp ips
		        var xmppHosts = self.getHostsByTag(data, 'xmpp');
		        if (!xmppHosts) {
		            console.log('xmpp hosts error3');
		            return;
		        }
		        self.xmppHosts = xmppHosts;
		        self.xmppTotal = xmppHosts.length;

		        self.getRestFromHttpDNS(options, type);
		    };
		    var error = function error(res, xhr, msg) {

		        console.log('getHttpDNS error', res, msg);
		        self.dnsIndex++;
		        if (self.dnsIndex < self.dnsTotal) {
		            self.getHttpDNS(options, type);
		        }
		    };
		    var options2 = {
		        url: this.dnsArr[this.dnsIndex] + '/easemob/server.xml',
		        dataType: 'text',
		        type: 'GET',

		        // url: 'http://www.easemob.com/easemob/server.xml',
		        // dataType: 'xml',
		        data: { app_key: encodeURIComponent(options.appKey) },
		        success: suc || _utils.emptyfn,
		        error: error || _utils.emptyfn
		    };
		    _utils.ajax(options2);
		};

		connection.prototype.signup = function (options) {
		    var self = this;
		    var orgName = options.orgName || '';
		    var appName = options.appName || '';
		    var appKey = options.appKey || '';
		    var suc = options.success || EMPTYFN;
		    var err = options.error || EMPTYFN;

		    if (!orgName && !appName && appKey) {
		        var devInfos = appKey.split('#');
		        if (devInfos.length === 2) {
		            orgName = devInfos[0];
		            appName = devInfos[1];
		        }
		    }
		    if (!orgName && !appName) {
		        err({
		            type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR
		        });
		        return;
		    }

		    var error = function error(res, xhr, msg) {
		        if (location.protocol != 'https:' && self.isHttpDNS) {
		            if (self.restIndex + 1 < self.restTotal) {
		                self.restIndex++;
		                self.getRestFromHttpDNS(options, 'signup');
		                return;
		            }
		        }
		        self.clear();
		        err(res);
		    };
		    var https = options.https || https;
		    var apiUrl = options.apiUrl;
		    var restUrl = apiUrl + '/' + orgName + '/' + appName + '/users';

		    var userjson = {
		        username: options.username,
		        password: options.password,
		        nickname: options.nickname || ''
		    };

		    var userinfo = _utils.stringify(userjson);
		    var options2 = {
		        url: restUrl,
		        dataType: 'json',
		        data: userinfo,
		        success: suc,
		        error: error
		    };
		    _utils.ajax(options2);
		};

		connection.prototype.open = function (options) {
		    if (location.protocol != 'https:' && this.isHttpDNS) {
		        this.dnsIndex = 0;
		        this.getHttpDNS(options, 'login');
		    } else {
		        this.login(options);
		    }
		};

		connection.prototype.login = function (options) {
		    var pass = _validCheck(options, this);

		    if (!pass) {
		        return;
		    }

		    var conn = this;

		    if (conn.isOpened()) {
		        return;
		    }

		    if (options.accessToken) {
		        options.access_token = options.accessToken;
		        _login(options, conn);
		    } else {
		        var apiUrl = options.apiUrl;
		        var userId = this.context.userId;
		        var pwd = options.pwd || '';
		        var appName = this.context.appName;
		        var orgName = this.context.orgName;

		        var suc = function suc(data, xhr) {
		            conn.context.status = _code.STATUS_DOLOGIN_IM;
		            conn.context.restTokenData = data;
		            options.success(data);
		            _login(data, conn);
		        };
		        var error = function error(res, xhr, msg) {
		            options.error();
		            if (location.protocol != 'https:' && conn.isHttpDNS) {
		                if (conn.restIndex + 1 < conn.restTotal) {
		                    conn.restIndex++;
		                    conn.getRestFromHttpDNS(options, 'login');
		                    return;
		                }
		            }
		            conn.clear();
		            if (res.error && res.error_description) {
		                conn.onError({
		                    type: _code.WEBIM_CONNCTION_OPEN_USERGRID_ERROR,
		                    data: res,
		                    xhr: xhr
		                });
		            } else {
		                conn.onError({
		                    type: _code.WEBIM_CONNCTION_OPEN_ERROR,
		                    data: res,
		                    xhr: xhr
		                });
		            }
		        };

		        this.context.status = _code.STATUS_DOLOGIN_USERGRID;

		        var loginJson = {
		            grant_type: 'password',
		            username: userId,
		            password: pwd,
		            timestamp: +new Date()
		        };
		        var loginfo = _utils.stringify(loginJson);

		        var options2 = {
		            url: apiUrl + '/' + orgName + '/' + appName + '/token',
		            dataType: 'json',
		            data: loginfo,
		            success: suc || _utils.emptyfn,
		            error: error || _utils.emptyfn
		        };
		        _utils.ajax(options2);
		    }
		};

		// attach to xmpp server for BOSH
		connection.prototype.attach = function (options) {
		    var pass = _validCheck(options, this);

		    if (!pass) {
		        return;
		    }

		    options = options || {};

		    var accessToken = options.accessToken || '';
		    if (accessToken == '') {
		        this.onError({
		            type: _code.WEBIM_CONNCTION_TOKEN_NOT_ASSIGN_ERROR
		        });
		        return;
		    }

		    var sid = options.sid || '';
		    if (sid === '') {
		        this.onError({
		            type: _code.WEBIM_CONNCTION_SESSIONID_NOT_ASSIGN_ERROR
		        });
		        return;
		    }

		    var rid = options.rid || '';
		    if (rid === '') {
		        this.onError({
		            type: _code.WEBIM_CONNCTION_RID_NOT_ASSIGN_ERROR
		        });
		        return;
		    }

		    var stropheConn = this.getStrophe();

		    this.context.accessToken = accessToken;
		    this.context.stropheConn = stropheConn;
		    this.context.status = _code.STATUS_DOLOGIN_IM;

		    var conn = this;
		    var callback = function callback(status, msg) {
		        _loginCallback(status, msg, conn);
		    };

		    var jid = this.context.jid;
		    var wait = this.wait;
		    var hold = this.hold;
		    var wind = this.wind || 5;
		    stropheConn.attach(jid, sid, rid, callback, wait, hold, wind);
		};

		connection.prototype.close = function (reason) {
		    this.stopHeartBeat();

		    var status = this.context.status;
		    if (status == _code.STATUS_INIT) {
		        return;
		    }

		    if (this.isClosed() || this.isClosing()) {
		        return;
		    }

		    this.context.status = _code.STATUS_CLOSING;
		    this.context.stropheConn.disconnect(reason);
		};

		connection.prototype.addHandler = function (handler, ns, name, type, id, from, options) {
		    this.context.stropheConn.addHandler(handler, ns, name, type, id, from, options);
		};

		connection.prototype.notifyVersion = function (suc, fail) {
		    var jid = _getJid({}, this);
		    var dom = $iq({
		        from: this.context.jid || '',
		        to: this.domain,
		        type: 'result'
		    }).c('query', { xmlns: 'jabber:iq:version' }).c('name').t('easemob').up().c('version').t(_version).up().c('os').t('webim');

		    var suc = suc || _utils.emptyfn;
		    var error = fail || this.onError;
		    var failFn = function failFn(ele) {
		        error({
		            type: _code.WEBIM_CONNCTION_NOTIFYVERSION_ERROR,
		            data: ele
		        });
		    };
		    this.context.stropheConn.sendIQ(dom.tree(), suc, failFn);
		    return;
		};

		// handle all types of presence message
		connection.prototype.handlePresence = function (msginfo) {
		    if (this.isClosed()) {
		        return;
		    }
		    var from = msginfo.getAttribute('from') || '';
		    var to = msginfo.getAttribute('to') || '';
		    var type = msginfo.getAttribute('type') || '';
		    var presence_type = msginfo.getAttribute('presence_type') || '';
		    var fromUser = _parseNameFromJidFn(from);
		    var toUser = _parseNameFromJidFn(to);
		    var isCreate = false;
		    var info = {
		        from: fromUser,
		        to: toUser,
		        fromJid: from,
		        toJid: to,
		        type: type,
		        chatroom: msginfo.getElementsByTagName('roomtype').length ? true : false
		    };

		    var showTags = msginfo.getElementsByTagName('show');
		    if (showTags && showTags.length > 0) {
		        var showTag = showTags[0];
		        info.show = Strophe.getText(showTag);
		    }
		    var statusTags = msginfo.getElementsByTagName('status');
		    if (statusTags && statusTags.length > 0) {
		        var statusTag = statusTags[0];
		        info.status = Strophe.getText(statusTag);
		        info.code = statusTag.getAttribute('code');
		    }

		    var priorityTags = msginfo.getElementsByTagName('priority');
		    if (priorityTags && priorityTags.length > 0) {
		        var priorityTag = priorityTags[0];
		        info.priority = Strophe.getText(priorityTag);
		    }

		    var error = msginfo.getElementsByTagName('error');
		    if (error && error.length > 0) {
		        var error = error[0];
		        info.error = {
		            code: error.getAttribute('code')
		        };
		    }

		    var destroy = msginfo.getElementsByTagName('destroy');
		    if (destroy && destroy.length > 0) {
		        var destroy = destroy[0];
		        info.destroy = true;

		        var reason = destroy.getElementsByTagName('reason');
		        if (reason && reason.length > 0) {
		            info.reason = Strophe.getText(reason[0]);
		        }
		    }

		    var members = msginfo.getElementsByTagName('item');
		    if (members && members.length > 0) {
		        var member = members[0];
		        var role = member.getAttribute('role');
		        var jid = member.getAttribute('jid');
		        var affiliation = member.getAttribute('affiliation');
		        // dismissed by group
		        if (role == 'none' && jid) {
		            var kickedMember = _parseNameFromJidFn(jid);
		            var actor = member.getElementsByTagName('actor')[0];
		            var actorNick = actor.getAttribute('nick');
		            info.actor = actorNick;
		            info.kicked = kickedMember;
		        }
		        // Service Acknowledges Room Creation `createGroupACK`
		        if (role == 'moderator' && info.code == '201') {
		            if (affiliation === 'owner') {
		                info.type = 'createGroupACK';
		                isCreate = true;
		            } else info.type = 'joinPublicGroupSuccess';
		        }
		    }

		    var apply = msginfo.getElementsByTagName('apply');
		    if (apply && apply.length > 0) {
		        apply = apply[0];
		        var toNick = apply.getAttribute('toNick');
		        var groupJid = apply.getAttribute('to');
		        var userJid = apply.getAttribute('from');
		        var groupName = _parseNameFromJidFn(groupJid);
		        var userName = _parseNameFromJidFn(userJid);
		        info.toNick = toNick;
		        info.groupName = groupName;
		        info.type = 'joinGroupNotifications';
		        var reason = apply.getElementsByTagName('reason');
		        if (reason && reason.length > 0) {
		            info.reason = Strophe.getText(reason[0]);
		        }
		    }

		    if (info.chatroom) {
		        // diff the
		        info.presence_type = presence_type;
		        info.original_type = info.type;
		        var reflectUser = from.slice(from.lastIndexOf('/') + 1);

		        if (reflectUser === this.context.userId) {
		            if (info.type === '' && !info.code) {
		                info.type = 'joinChatRoomSuccess';
		            } else if (presence_type === 'unavailable' || info.type === 'unavailable') {
		                if (!info.status) {
		                    // logout successfully.
		                    info.type = 'leaveChatRoom';
		                } else if (info.code == 110) {
		                    // logout or dismissied by admin.
		                    info.type = 'leaveChatRoom';
		                } else if (info.error && info.error.code == 406) {
		                    // The chat room is full.
		                    info.type = 'reachChatRoomCapacity';
		                }
		            }
		        }
		    } else {
		        info.presence_type = presence_type;
		        info.original_type = type;

		        if (/subscribe/.test(info.type)) {
		            //subscribe | subscribed | unsubscribe | unsubscribed
		        } else if (type == "" && !info.status && !info.error && !isCreate) {
		            info.type = 'joinPublicGroupSuccess';
		        } else if (presence_type === 'unavailable' || type === 'unavailable') {
		            // There is no roomtype when a chat room is deleted.
		            if (info.destroy) {
		                // Group or Chat room Deleted.
		                info.type = 'deleteGroupChat';
		            } else if (info.code == 307 || info.code == 321) {
		                // Dismissed by group.
		                var nick = msginfo.getAttribute('nick');
		                if (!nick) info.type = 'leaveGroup';else info.type = 'removedFromGroup';
		            }
		        }
		    }
		    this.onPresence(info, msginfo);
		};

		connection.prototype.handlePing = function (e) {
		    if (this.isClosed()) {
		        return;
		    }
		    var id = e.getAttribute('id');
		    var from = e.getAttribute('from');
		    var to = e.getAttribute('to');
		    var dom = $iq({
		        from: to,
		        to: from,
		        id: id,
		        type: 'result'
		    });
		    this.sendCommand(dom.tree());
		};

		connection.prototype.handleIq = function (iq) {
		    return true;
		};

		connection.prototype.handleIqPrivacy = function (msginfo) {
		    var list = msginfo.getElementsByTagName('list');
		    if (list.length == 0) {
		        return;
		    }
		    this.getBlacklist();
		};

		connection.prototype.handleIqRoster = function (e) {
		    var id = e.getAttribute('id');
		    var from = e.getAttribute('from') || '';
		    var name = _parseNameFromJidFn(from);
		    var curJid = this.context.jid;
		    var curUser = this.context.userId;

		    var iqresult = $iq({ type: 'result', id: id, from: curJid });
		    this.sendCommand(iqresult.tree());

		    var msgBodies = e.getElementsByTagName('query');
		    if (msgBodies && msgBodies.length > 0) {
		        var queryTag = msgBodies[0];
		        var rouster = _parseFriend(queryTag, this, from);
		        this.onRoster(rouster);
		    }
		    return true;
		};

		connection.prototype.handleMessage = function (msginfo) {
		    var self = this;
		    if (this.isClosed()) {
		        return;
		    }

		    var id = msginfo.getAttribute('id') || '';

		    // cache ack into sendQueue first , handelSendQueue will do the send thing with the speed of  5/s
		    this.cacheReceiptsMessage({
		        id: id
		    });
		    var parseMsgData = _parseResponseMessage(msginfo);
		    if (parseMsgData.errorMsg) {
		        this.handlePresence(msginfo);
		        return;
		    }
		    // send error
		    var error = msginfo.getElementsByTagName('error');
		    var errorCode = '';
		    var errorText = '';
		    var errorBool = false;
		    if (error.length > 0) {
		        errorBool = true;
		        errorCode = error[0].getAttribute('code');
		        var textDOM = error[0].getElementsByTagName('text');
		        errorText = textDOM[0].textContent || textDOM[0].text;
		        log('handle error', errorCode, errorText);
		    }

		    var msgDatas = parseMsgData.data;
		    for (var i in msgDatas) {
		        if (!msgDatas.hasOwnProperty(i)) {
		            continue;
		        }
		        var msg = msgDatas[i];
		        if (!msg.from || !msg.to) {
		            continue;
		        }

		        var from = (msg.from + '').toLowerCase();
		        var too = (msg.to + '').toLowerCase();
		        var extmsg = msg.ext || {};
		        var chattype = '';
		        var typeEl = msginfo.getElementsByTagName('roomtype');
		        if (typeEl.length) {
		            chattype = typeEl[0].getAttribute('type') || 'chat';
		        } else {
		            chattype = msginfo.getAttribute('type') || 'chat';
		        }

		        var msgBodies = msg.bodies;
		        if (!msgBodies || msgBodies.length == 0) {
		            continue;
		        }
		        var msgBody = msg.bodies[0];
		        var type = msgBody.type;

		        try {
		            switch (type) {
		                case 'txt':
		                    var receiveMsg = msgBody.msg;
		                    var emojibody = _utils.parseTextMessage(receiveMsg, WebIM.Emoji);
		                    if (emojibody.isemoji) {
		                        var msg = {
		                            id: id,
		                            type: chattype,
		                            from: from,
		                            to: too,
		                            delay: parseMsgData.delayTimeStamp,
		                            data: emojibody.body,
		                            ext: extmsg
		                        };
		                        !msg.delay && delete msg.delay;
		                        msg.error = errorBool;
		                        msg.errorText = errorText;
		                        msg.errorCode = errorCode;
		                        this.onEmojiMessage(msg);
		                    } else {
		                        var msg = {
		                            id: id,
		                            type: chattype,
		                            from: from,
		                            to: too,
		                            delay: parseMsgData.delayTimeStamp,
		                            data: receiveMsg,
		                            ext: extmsg
		                        };
		                        !msg.delay && delete msg.delay;
		                        msg.error = errorBool;
		                        msg.errorText = errorText;
		                        msg.errorCode = errorCode;
		                        this.onTextMessage(msg);
		                    }
		                    break;
		                case 'img':
		                    var rwidth = 0;
		                    var rheight = 0;
		                    if (msgBody.size) {
		                        rwidth = msgBody.size.width;
		                        rheight = msgBody.size.height;
		                    }
		                    var msg = {
		                        id: id,
		                        type: chattype,
		                        from: from,
		                        to: too,

		                        url: location.protocol != 'https:' && self.isHttpDNS ? self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9)) : msgBody.url,
		                        secret: msgBody.secret,
		                        filename: msgBody.filename,
		                        thumb: msgBody.thumb,
		                        thumb_secret: msgBody.thumb_secret,
		                        file_length: msgBody.file_length || '',
		                        width: rwidth,
		                        height: rheight,
		                        filetype: msgBody.filetype || '',
		                        accessToken: this.context.accessToken || '',
		                        ext: extmsg,
		                        delay: parseMsgData.delayTimeStamp
		                    };
		                    !msg.delay && delete msg.delay;
		                    msg.error = errorBool;
		                    msg.errorText = errorText;
		                    msg.errorCode = errorCode;
		                    this.onPictureMessage(msg);
		                    break;
		                case 'audio':
		                    var msg = {
		                        id: id,
		                        type: chattype,
		                        from: from,
		                        to: too,

		                        url: location.protocol != 'https:' && self.isHttpDNS ? self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9)) : msgBody.url,
		                        secret: msgBody.secret,
		                        filename: msgBody.filename,
		                        length: msgBody.length || '',
		                        file_length: msgBody.file_length || '',
		                        filetype: msgBody.filetype || '',
		                        accessToken: this.context.accessToken || '',
		                        ext: extmsg,
		                        delay: parseMsgData.delayTimeStamp
		                    };
		                    !msg.delay && delete msg.delay;
		                    msg.error = errorBool;
		                    msg.errorText = errorText;
		                    msg.errorCode = errorCode;
		                    this.onAudioMessage(msg);
		                    break;
		                case 'file':
		                    var msg = {
		                        id: id,
		                        type: chattype,
		                        from: from,
		                        to: too,

		                        url: location.protocol != 'https:' && self.isHttpDNS ? self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9)) : msgBody.url,
		                        secret: msgBody.secret,
		                        filename: msgBody.filename,
		                        file_length: msgBody.file_length,
		                        accessToken: this.context.accessToken || '',
		                        ext: extmsg,
		                        delay: parseMsgData.delayTimeStamp
		                    };
		                    !msg.delay && delete msg.delay;
		                    msg.error = errorBool;
		                    msg.errorText = errorText;
		                    msg.errorCode = errorCode;
		                    this.onFileMessage(msg);
		                    break;
		                case 'loc':
		                    var msg = {
		                        id: id,
		                        type: chattype,
		                        from: from,
		                        to: too,
		                        addr: msgBody.addr,
		                        lat: msgBody.lat,
		                        lng: msgBody.lng,
		                        ext: extmsg,
		                        delay: parseMsgData.delayTimeStamp
		                    };
		                    !msg.delay && delete msg.delay;
		                    msg.error = errorBool;
		                    msg.errorText = errorText;
		                    msg.errorCode = errorCode;
		                    this.onLocationMessage(msg);
		                    break;
		                case 'video':
		                    var msg = {
		                        id: id,
		                        type: chattype,
		                        from: from,
		                        to: too,

		                        url: location.protocol != 'https:' && self.isHttpDNS ? self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9)) : msgBody.url,
		                        secret: msgBody.secret,
		                        filename: msgBody.filename,
		                        file_length: msgBody.file_length,
		                        accessToken: this.context.accessToken || '',
		                        ext: extmsg,
		                        delay: parseMsgData.delayTimeStamp
		                    };
		                    !msg.delay && delete msg.delay;
		                    msg.error = errorBool;
		                    msg.errorText = errorText;
		                    msg.errorCode = errorCode;
		                    this.onVideoMessage(msg);
		                    break;
		                case 'cmd':
		                    var msg = {
		                        id: id,
		                        from: from,
		                        to: too,
		                        action: msgBody.action,
		                        ext: extmsg,
		                        delay: parseMsgData.delayTimeStamp
		                    };
		                    !msg.delay && delete msg.delay;
		                    msg.error = errorBool;
		                    msg.errorText = errorText;
		                    msg.errorCode = errorCode;
		                    this.onCmdMessage(msg);
		                    break;
		            }
		            ;
		        } catch (e) {
		            this.onError({
		                type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR,
		                data: e
		            });
		        }
		    }
		};

		connection.prototype.handleReceivedMessage = function (message) {
		    try {
		        this.onReceivedMessage(message);
		    } catch (e) {
		        this.onError({
		            type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR,
		            data: e
		        });
		    }

		    var rcv = message.getElementsByTagName('received'),
		        id,
		        mid;

		    if (rcv.length > 0) {
		        if (rcv[0].childNodes && rcv[0].childNodes.length > 0) {
		            id = rcv[0].childNodes[0].nodeValue;
		        } else {
		            id = rcv[0].innerHTML || rcv[0].innerText;
		        }
		        mid = rcv[0].getAttribute('mid');
		    }

		    if (_msgHash[id]) {
		        try {
		            _msgHash[id].msg.success instanceof Function && _msgHash[id].msg.success(id, mid);
		        } catch (e) {
		            this.onError({
		                type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR,
		                data: e
		            });
		        }
		        delete _msgHash[id];
		    }
		};

		connection.prototype.handleInviteMessage = function (message) {
		    var form = null;
		    var invitemsg = message.getElementsByTagName('invite');
		    var reasonDom = message.getElementsByTagName('reason')[0];
		    var reasonMsg = reasonDom.textContent;
		    var id = message.getAttribute('id') || '';
		    this.sendReceiptsMessage({
		        id: id
		    });

		    if (invitemsg && invitemsg.length > 0) {
		        var fromJid = invitemsg[0].getAttribute('from');
		        form = _parseNameFromJidFn(fromJid);
		    }
		    var xmsg = message.getElementsByTagName('x');
		    var roomid = null;
		    if (xmsg && xmsg.length > 0) {
		        for (var i = 0; i < xmsg.length; i++) {
		            if ('jabber:x:conference' === xmsg[i].namespaceURI) {
		                var roomjid = xmsg[i].getAttribute('jid');
		                roomid = _parseNameFromJidFn(roomjid);
		            }
		        }
		    }
		    this.onInviteMessage({
		        type: 'invite',
		        from: form,
		        roomid: roomid,
		        reason: reasonMsg
		    });
		};

		connection.prototype.sendCommand = function (dom, id) {
		    if (this.isOpened()) {
		        this.context.stropheConn.send(dom);
		    } else {
		        this.onError({
		            type: _code.WEBIM_CONNCTION_DISCONNECTED,
		            reconnect: true
		        });
		    }
		};

		connection.prototype.getUniqueId = function (prefix) {
		    var cdate = new Date();
		    var offdate = new Date(2010, 1, 1);
		    var offset = cdate.getTime() - offdate.getTime();
		    var hexd = parseInt(offset).toString(16);

		    if (typeof prefix === 'string' || typeof prefix === 'number') {
		        return prefix + '_' + hexd;
		    } else {
		        return 'WEBIM_' + hexd;
		    }
		};

		connection.prototype.send = function (message) {
		    var self = this;
		    if (this.isWindowSDK) {
		        WebIM.doQuery('{"type":"sendMessage","to":"' + message.to + '","message_type":"' + message.type + '","msg":"' + encodeURI(message.msg) + '","chatType":"' + message.chatType + '"}', function (response) {}, function (code, msg) {
		            var message = {
		                data: {
		                    data: "send"
		                },
		                type: _code.WEBIM_MESSAGE_SED_ERROR
		            };
		            self.onError(message);
		        });
		    } else {
		        if (Object.prototype.toString.call(message) === '[object Object]') {
		            var appKey = this.context.appKey || '';
		            var toJid = appKey + '_' + message.to + '@' + this.domain;

		            if (message.group) {
		                toJid = appKey + '_' + message.to + '@conference.' + this.domain;
		            }
		            if (message.resource) {
		                toJid = toJid + '/' + message.resource;
		            }

		            message.toJid = toJid;
		            message.id = message.id || this.getUniqueId();
		            _msgHash[message.id] = new _message(message);
		            _msgHash[message.id].send(this);
		        } else if (typeof message === 'string') {
		            _msgHash[message] && _msgHash[message].send(this);
		        }
		    }
		};

		connection.prototype.addRoster = function (options) {
		    var jid = _getJid(options, this);
		    var name = options.name || '';
		    var groups = options.groups || '';

		    var iq = $iq({ type: 'set' });
		    iq.c('query', { xmlns: 'jabber:iq:roster' });
		    iq.c('item', { jid: jid, name: name });

		    if (groups) {
		        for (var i = 0; i < groups.length; i++) {
		            iq.c('group').t(groups[i]).up();
		        }
		    }
		    var suc = options.success || _utils.emptyfn;
		    var error = options.error || _utils.emptyfn;
		    this.context.stropheConn.sendIQ(iq.tree(), suc, error);
		};

		connection.prototype.removeRoster = function (options) {
		    var jid = _getJid(options, this);
		    var iq = $iq({ type: 'set' }).c('query', { xmlns: 'jabber:iq:roster' }).c('item', {
		        jid: jid,
		        subscription: 'remove'
		    });

		    var suc = options.success || _utils.emptyfn;
		    var error = options.error || _utils.emptyfn;
		    this.context.stropheConn.sendIQ(iq, suc, error);
		};

		connection.prototype.getRoster = function (options) {
		    var conn = this;
		    var dom = $iq({
		        type: 'get'
		    }).c('query', { xmlns: 'jabber:iq:roster' });

		    var options = options || {};
		    var suc = options.success || this.onRoster;
		    var completeFn = function completeFn(ele) {
		        var rouster = [];
		        var msgBodies = ele.getElementsByTagName('query');
		        if (msgBodies && msgBodies.length > 0) {
		            var queryTag = msgBodies[0];
		            rouster = _parseFriend(queryTag);
		        }
		        suc(rouster, ele);
		    };
		    var error = options.error || this.onError;
		    var failFn = function failFn(ele) {
		        error({
		            type: _code.WEBIM_CONNCTION_GETROSTER_ERROR,
		            data: ele
		        });
		    };
		    if (this.isOpened()) {
		        this.context.stropheConn.sendIQ(dom.tree(), completeFn, failFn);
		    } else {
		        error({
		            type: _code.WEBIM_CONNCTION_DISCONNECTED
		        });
		    }
		};

		connection.prototype.subscribe = function (options) {
		    var jid = _getJid(options, this);
		    var pres = $pres({ to: jid, type: 'subscribe' });
		    if (options.message) {
		        pres.c('status').t(options.message).up();
		    }
		    if (options.nick) {
		        pres.c('nick', { 'xmlns': 'http://jabber.org/protocol/nick' }).t(options.nick);
		    }
		    this.sendCommand(pres.tree());
		};

		connection.prototype.subscribed = function (options) {
		    var jid = _getJid(options, this);
		    var pres = $pres({ to: jid, type: 'subscribed' });

		    if (options.message) {
		        pres.c('status').t(options.message).up();
		    }
		    this.sendCommand(pres.tree());
		};

		connection.prototype.unsubscribe = function (options) {
		    var jid = _getJid(options, this);
		    var pres = $pres({ to: jid, type: 'unsubscribe' });

		    if (options.message) {
		        pres.c('status').t(options.message);
		    }
		    this.sendCommand(pres.tree());
		};

		connection.prototype.unsubscribed = function (options) {
		    var jid = _getJid(options, this);
		    var pres = $pres({ to: jid, type: 'unsubscribed' });

		    if (options.message) {
		        pres.c('status').t(options.message).up();
		    }
		    this.sendCommand(pres.tree());
		};

		connection.prototype.joinPublicGroup = function (options) {
		    var roomJid = this.context.appKey + '_' + options.roomId + '@conference.' + this.domain;
		    var room_nick = roomJid + '/' + this.context.userId;
		    var suc = options.success || _utils.emptyfn;
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_JOINROOM_ERROR,
		            data: ele
		        });
		    };
		    var iq = $pres({
		        from: this.context.jid,
		        to: room_nick
		    }).c('x', { xmlns: Strophe.NS.MUC });

		    this.context.stropheConn.sendIQ(iq.tree(), suc, errorFn);
		};

		connection.prototype.listRooms = function (options) {
		    var iq = $iq({
		        to: options.server || 'conference.' + this.domain,
		        from: this.context.jid,
		        type: 'get'
		    }).c('query', { xmlns: Strophe.NS.DISCO_ITEMS });

		    var suc = options.success || _utils.emptyfn;
		    var error = options.error || this.onError;
		    var completeFn = function completeFn(result) {
		        var rooms = [];
		        rooms = _parseRoom(result);
		        try {
		            suc(rooms);
		        } catch (e) {
		            error({
		                type: _code.WEBIM_CONNCTION_GETROOM_ERROR,
		                data: e
		            });
		        }
		    };
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_GETROOM_ERROR,
		            data: ele
		        });
		    };
		    this.context.stropheConn.sendIQ(iq.tree(), completeFn, errorFn);
		};

		connection.prototype.queryRoomMember = function (options) {
		    var domain = this.domain;
		    var members = [];
		    var iq = $iq({
		        to: this.context.appKey + '_' + options.roomId + '@conference.' + this.domain,
		        type: 'get'
		    }).c('query', { xmlns: Strophe.NS.MUC + '#admin' }).c('item', { affiliation: 'member' });

		    var suc = options.success || _utils.emptyfn;
		    var completeFn = function completeFn(result) {
		        var items = result.getElementsByTagName('item');

		        if (items) {
		            for (var i = 0; i < items.length; i++) {
		                var item = items[i];
		                var mem = {
		                    jid: item.getAttribute('jid'),
		                    affiliation: 'member'
		                };
		                members.push(mem);
		            }
		        }
		        suc(members);
		    };
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_GETROOMMEMBER_ERROR,
		            data: ele
		        });
		    };
		    this.context.stropheConn.sendIQ(iq.tree(), completeFn, errorFn);
		};

		connection.prototype.queryRoomInfo = function (options) {
		    var domain = this.domain;
		    var iq = $iq({
		        to: this.context.appKey + '_' + options.roomId + '@conference.' + domain,
		        type: 'get'
		    }).c('query', { xmlns: Strophe.NS.DISCO_INFO });

		    var suc = options.success || _utils.emptyfn;
		    var members = [];

		    var completeFn = function completeFn(result) {
		        var settings = '';
		        var features = result.getElementsByTagName('feature');
		        if (features) {
		            settings = features[1].getAttribute('var') + '|' + features[3].getAttribute('var') + '|' + features[4].getAttribute('var');
		        }
		        switch (settings) {
		            case 'muc_public|muc_membersonly|muc_notallowinvites':
		                settings = 'PUBLIC_JOIN_APPROVAL';
		                break;
		            case 'muc_public|muc_open|muc_notallowinvites':
		                settings = 'PUBLIC_JOIN_OPEN';
		                break;
		            case 'muc_hidden|muc_membersonly|muc_allowinvites':
		                settings = 'PRIVATE_MEMBER_INVITE';
		                break;
		            case 'muc_hidden|muc_membersonly|muc_notallowinvites':
		                settings = 'PRIVATE_OWNER_INVITE';
		                break;
		        }
		        var owner = '';
		        var fields = result.getElementsByTagName('field');
		        var fieldValues = {};
		        if (fields) {
		            for (var i = 0; i < fields.length; i++) {
		                var field = fields[i];
		                var fieldVar = field.getAttribute('var');
		                var fieldSimplify = fieldVar.split('_')[1];
		                switch (fieldVar) {
		                    case 'muc#roominfo_occupants':
		                    case 'muc#roominfo_maxusers':
		                    case 'muc#roominfo_affiliations':
		                    case 'muc#roominfo_description':
		                        fieldValues[fieldSimplify] = field.textContent || field.text || '';
		                        break;
		                    case 'muc#roominfo_owner':
		                        var mem = {
		                            jid: (field.textContent || field.text) + '@' + domain,
		                            affiliation: 'owner'
		                        };
		                        members.push(mem);
		                        fieldValues[fieldSimplify] = field.textContent || field.text;
		                        break;
		                }

		                // if (field.getAttribute('label') === 'owner') {
		                //     var mem = {
		                //         jid: (field.textContent || field.text) + '@' + domain
		                //         , affiliation: 'owner'
		                //     };
		                //     members.push(mem);
		                //     break;
		                // }
		            }
		            fieldValues['name'] = result.getElementsByTagName('identity')[0].getAttribute('name');
		        }
		        log(settings, members, fieldValues);
		        suc(settings, members, fieldValues);
		    };
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_GETROOMINFO_ERROR,
		            data: ele
		        });
		    };
		    this.context.stropheConn.sendIQ(iq.tree(), completeFn, errorFn);
		};

		connection.prototype.queryRoomOccupants = function (options) {
		    var suc = options.success || _utils.emptyfn;
		    var completeFn = function completeFn(result) {
		        var occupants = [];
		        occupants = _parseRoomOccupants(result);
		        suc(occupants);
		    };
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_GETROOMOCCUPANTS_ERROR,
		            data: ele
		        });
		    };
		    var attrs = {
		        xmlns: Strophe.NS.DISCO_ITEMS
		    };
		    var info = $iq({
		        from: this.context.jid,
		        to: this.context.appKey + '_' + options.roomId + '@conference.' + this.domain,
		        type: 'get'
		    }).c('query', attrs);
		    this.context.stropheConn.sendIQ(info.tree(), completeFn, errorFn);
		};

		connection.prototype.setUserSig = function (desc) {
		    var dom = $pres({ xmlns: 'jabber:client' });
		    desc = desc || '';
		    dom.c('status').t(desc);
		    this.sendCommand(dom.tree());
		};

		connection.prototype.setPresence = function (type, status) {
		    var dom = $pres({ xmlns: 'jabber:client' });
		    if (type) {
		        if (status) {
		            dom.c('show').t(type);
		            dom.up().c('status').t(status);
		        } else {
		            dom.c('show').t(type);
		        }
		    }
		    this.sendCommand(dom.tree());
		};

		connection.prototype.getPresence = function () {
		    var dom = $pres({ xmlns: 'jabber:client' });
		    var conn = this;
		    this.sendCommand(dom.tree());
		};

		connection.prototype.ping = function (options) {
		    var options = options || {};
		    var jid = _getJid(options, this);

		    var dom = $iq({
		        from: this.context.jid || '',
		        to: jid,
		        type: 'get'
		    }).c('ping', { xmlns: 'urn:xmpp:ping' });

		    var suc = options.success || _utils.emptyfn;
		    var error = options.error || this.onError;
		    var failFn = function failFn(ele) {
		        error({
		            type: _code.WEBIM_CONNCTION_PING_ERROR,
		            data: ele
		        });
		    };
		    if (this.isOpened()) {
		        this.context.stropheConn.sendIQ(dom.tree(), suc, failFn);
		    } else {
		        error({
		            type: _code.WEBIM_CONNCTION_DISCONNECTED
		        });
		    }
		    return;
		};

		connection.prototype.isOpened = function () {
		    return this.context.status == _code.STATUS_OPENED;
		};

		connection.prototype.isOpening = function () {
		    var status = this.context.status;
		    return status == _code.STATUS_DOLOGIN_USERGRID || status == _code.STATUS_DOLOGIN_IM;
		};

		connection.prototype.isClosing = function () {
		    return this.context.status == _code.STATUS_CLOSING;
		};

		connection.prototype.isClosed = function () {
		    return this.context.status == _code.STATUS_CLOSED;
		};

		connection.prototype.clear = function () {
		    var key = this.context.appKey;
		    if (this.errorType != _code.WEBIM_CONNCTION_DISCONNECTED) {
		        this.context = {
		            status: _code.STATUS_INIT,
		            appKey: key
		        };
		    }
		    if (this.intervalId) {
		        clearInterval(this.intervalId);
		    }
		    this.restIndex = 0;
		    this.xmppIndex = 0;

		    if (this.errorType == _code.WEBIM_CONNCTION_CLIENT_LOGOUT || this.errorType == -1) {
		        var message = {
		            data: {
		                data: "logout"
		            },
		            type: _code.WEBIM_CONNCTION_CLIENT_LOGOUT
		        };
		        this.onError(message);
		    }
		};

		connection.prototype.getChatRooms = function (options) {

		    if (!_utils.isCanSetRequestHeader) {
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_NOT_SUPPORT_CHATROOM_ERROR
		        });
		        return;
		    }

		    var conn = this,
		        token = options.accessToken || this.context.accessToken;

		    if (token) {
		        var apiUrl = options.apiUrl;
		        var appName = this.context.appName;
		        var orgName = this.context.orgName;

		        if (!appName || !orgName) {
		            conn.onError({
		                type: _code.WEBIM_CONNCTION_AUTH_ERROR
		            });
		            return;
		        }

		        var suc = function suc(data, xhr) {
		            typeof options.success === 'function' && options.success(data);
		        };

		        var error = function error(res, xhr, msg) {
		            if (res.error && res.error_description) {
		                conn.onError({
		                    type: _code.WEBIM_CONNCTION_LOAD_CHATROOM_ERROR,
		                    msg: res.error_description,
		                    data: res,
		                    xhr: xhr
		                });
		            }
		        };

		        var pageInfo = {
		            pagenum: parseInt(options.pagenum) || 1,
		            pagesize: parseInt(options.pagesize) || 20
		        };

		        var opts = {
		            url: apiUrl + '/' + orgName + '/' + appName + '/chatrooms',
		            dataType: 'json',
		            type: 'GET',
		            headers: { 'Authorization': 'Bearer ' + token },
		            data: pageInfo,
		            success: suc || _utils.emptyfn,
		            error: error || _utils.emptyfn
		        };
		        _utils.ajax(opts);
		    } else {
		        conn.onError({
		            type: _code.WEBIM_CONNCTION_TOKEN_NOT_ASSIGN_ERROR
		        });
		    }
		};

		connection.prototype.joinChatRoom = function (options) {
		    var roomJid = this.context.appKey + '_' + options.roomId + '@conference.' + this.domain;
		    var room_nick = roomJid + '/' + this.context.userId;
		    var suc = options.success || _utils.emptyfn;
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_JOINCHATROOM_ERROR,
		            data: ele
		        });
		    };

		    var iq = $pres({
		        from: this.context.jid,
		        to: room_nick
		    }).c('x', { xmlns: Strophe.NS.MUC + '#user' }).c('item', { affiliation: 'member', role: 'participant' }).up().up().c('roomtype', { xmlns: 'easemob:x:roomtype', type: 'chatroom' });

		    this.context.stropheConn.sendIQ(iq.tree(), suc, errorFn);
		};

		connection.prototype.quitChatRoom = function (options) {
		    var roomJid = this.context.appKey + '_' + options.roomId + '@conference.' + this.domain;
		    var room_nick = roomJid + '/' + this.context.userId;
		    var suc = options.success || _utils.emptyfn;
		    var err = options.error || _utils.emptyfn;
		    var errorFn = function errorFn(ele) {
		        err({
		            type: _code.WEBIM_CONNCTION_QUITCHATROOM_ERROR,
		            data: ele
		        });
		    };
		    var iq = $pres({
		        from: this.context.jid,
		        to: room_nick,
		        type: 'unavailable'
		    }).c('x', { xmlns: Strophe.NS.MUC + '#user' }).c('item', { affiliation: 'none', role: 'none' }).up().up().c('roomtype', { xmlns: 'easemob:x:roomtype', type: 'chatroom' });

		    this.context.stropheConn.sendIQ(iq.tree(), suc, errorFn);
		};

		connection.prototype._onReceiveInviteFromGroup = function (info) {
		    info = eval('(' + info + ')');
		    var self = this;
		    var options = {
		        title: "Group invitation",
		        msg: info.user + " invites you to join into group:" + info.group_id,
		        agree: function agree() {
		            WebIM.doQuery('{"type":"acceptInvitationFromGroup","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) {}, function (code, msg) {
		                var message = {
		                    data: {
		                        data: "acceptInvitationFromGroup error:" + msg
		                    },
		                    type: _code.WEBIM_CONNECTION_ACCEPT_INVITATION_FROM_GROUP
		                };
		                self.onError(message);
		            });
		        },
		        reject: function reject() {
		            WebIM.doQuery('{"type":"declineInvitationFromGroup","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) {}, function (code, msg) {
		                var message = {
		                    data: {
		                        data: "declineInvitationFromGroup error:" + msg
		                    },
		                    type: _code.WEBIM_CONNECTION_DECLINE_INVITATION_FROM_GROUP
		                };
		                self.onError(message);
		            });
		        }
		    };

		    this.onConfirmPop(options);
		};
		connection.prototype._onReceiveInviteAcceptionFromGroup = function (info) {
		    info = eval('(' + info + ')');
		    var options = {
		        title: "Group invitation response",
		        msg: info.user + " agreed to join into group:" + info.group_id,
		        agree: function agree() {}
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onReceiveInviteDeclineFromGroup = function (info) {
		    info = eval('(' + info + ')');
		    var options = {
		        title: "Group invitation response",
		        msg: info.user + " rejected to join into group:" + info.group_id,
		        agree: function agree() {}
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onAutoAcceptInvitationFromGroup = function (info) {
		    info = eval('(' + info + ')');
		    var options = {
		        title: "Group invitation",
		        msg: "You had joined into the group:" + info.group_name + " automatically.Inviter:" + info.user,
		        agree: function agree() {}
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onLeaveGroup = function (info) {
		    info = eval('(' + info + ')');
		    var options = {
		        title: "Group notification",
		        msg: "You have been out of the group:" + info.group_id + ".Reason:" + info.msg,
		        agree: function agree() {}
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onReceiveJoinGroupApplication = function (info) {
		    info = eval('(' + info + ')');
		    var self = this;
		    var options = {
		        title: "Group join application",
		        msg: info.user + " applys to join into group:" + info.group_id,
		        agree: function agree() {
		            WebIM.doQuery('{"type":"acceptJoinGroupApplication","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) {}, function (code, msg) {
		                var message = {
		                    data: {
		                        data: "acceptJoinGroupApplication error:" + msg
		                    },
		                    type: _code.WEBIM_CONNECTION_ACCEPT_JOIN_GROUP
		                };
		                self.onError(message);
		            });
		        },
		        reject: function reject() {
		            WebIM.doQuery('{"type":"declineJoinGroupApplication","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) {}, function (code, msg) {
		                var message = {
		                    data: {
		                        data: "declineJoinGroupApplication error:" + msg
		                    },
		                    type: _code.WEBIM_CONNECTION_DECLINE_JOIN_GROUP
		                };
		                self.onError(message);
		            });
		        }
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onReceiveAcceptionFromGroup = function (info) {
		    info = eval('(' + info + ')');
		    var options = {
		        title: "Group notification",
		        msg: "You had joined into the group:" + info.group_name + ".",
		        agree: function agree() {}
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onReceiveRejectionFromGroup = function () {
		    info = eval('(' + info + ')');
		    var options = {
		        title: "Group notification",
		        msg: "You have been rejected to join into the group:" + info.group_name + ".",
		        agree: function agree() {}
		    };
		    this.onConfirmPop(options);
		};
		connection.prototype._onUpdateMyGroupList = function (options) {
		    this.onUpdateMyGroupList(options);
		};
		connection.prototype._onUpdateMyRoster = function (options) {
		    this.onUpdateMyRoster(options);
		};
		connection.prototype.reconnect = function () {
		    var that = this;
		    setTimeout(function () {
		        _login(that.context.restTokenData, that);
		    }, (this.autoReconnectNumTotal == 0 ? 0 : this.autoReconnectInterval) * 1000);
		    this.autoReconnectNumTotal++;
		};

		connection.prototype.closed = function () {
		    var message = {
		        data: {
		            data: "Closed error"
		        },
		        type: _code.WEBIM_CONNECTION_CLOSED
		    };
		    this.onError(message);
		};

		// used for blacklist
		function _parsePrivacy(iq) {
		    var list = [];
		    var items = iq.getElementsByTagName('item');

		    if (items) {
		        for (var i = 0; i < items.length; i++) {
		            var item = items[i];
		            var jid = item.getAttribute('value');
		            var order = item.getAttribute('order');
		            var type = item.getAttribute('type');
		            if (!jid) {
		                continue;
		            }
		            var n = _parseNameFromJidFn(jid);
		            list[n] = {
		                type: type,
		                order: order,
		                jid: jid,
		                name: n
		            };
		        }
		    }
		    return list;
		};

		// used for blacklist
		connection.prototype.getBlacklist = function (options) {
		    options = options || {};
		    var iq = $iq({ type: 'get' });
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;
		    var me = this;

		    iq.c('query', { xmlns: 'jabber:iq:privacy' }).c('list', { name: 'special' });

		    this.context.stropheConn.sendIQ(iq.tree(), function (iq) {
		        me.onBlacklistUpdate(_parsePrivacy(iq));
		        sucFn();
		    }, function () {
		        me.onBlacklistUpdate([]);
		        errFn();
		    });
		};

		// used for blacklist
		connection.prototype.addToBlackList = function (options) {
		    var iq = $iq({ type: 'set' });
		    var blacklist = options.list || {};
		    var type = options.type || 'jid';
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;
		    var piece = iq.c('query', { xmlns: 'jabber:iq:privacy' }).c('list', { name: 'special' });

		    var keys = Object.keys(blacklist);
		    var len = keys.length;
		    var order = 2;

		    for (var i = 0; i < len; i++) {
		        var item = blacklist[keys[i]];
		        var type = item.type || 'jid';
		        var jid = item.jid;

		        piece = piece.c('item', { action: 'deny', order: order++, type: type, value: jid }).c('message');
		        if (i !== len - 1) {
		            piece = piece.up().up();
		        }
		    }

		    // log('addToBlackList', blacklist, piece.tree());
		    this.context.stropheConn.sendIQ(piece.tree(), sucFn, errFn);
		};

		// used for blacklist
		connection.prototype.removeFromBlackList = function (options) {

		    var iq = $iq({ type: 'set' });
		    var blacklist = options.list || {};
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;
		    var piece = iq.c('query', { xmlns: 'jabber:iq:privacy' }).c('list', { name: 'special' });

		    var keys = Object.keys(blacklist);
		    var len = keys.length;

		    for (var i = 0; i < len; i++) {
		        var item = blacklist[keys[i]];
		        var type = item.type || 'jid';
		        var jid = item.jid;
		        var order = item.order;

		        piece = piece.c('item', { action: 'deny', order: order, type: type, value: jid }).c('message');
		        if (i !== len - 1) {
		            piece = piece.up().up();
		        }
		    }

		    // log('removeFromBlackList', blacklist, piece.tree());
		    this.context.stropheConn.sendIQ(piece.tree(), sucFn, errFn);
		};

		connection.prototype._getGroupJid = function (to) {
		    var appKey = this.context.appKey || '';
		    return appKey + '_' + to + '@conference.' + this.domain;
		};

		// used for blacklist
		connection.prototype.addToGroupBlackList = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;
		    var jid = _getJid(options, this);
		    var affiliation = 'admin'; //options.affiliation || 'admin';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });

		    iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation }).c('item', {
		        affiliation: 'outcast',
		        jid: jid
		    });

		    this.context.stropheConn.sendIQ(iq.tree(), sucFn, errFn);
		};

		function _parseGroupBlacklist(iq) {
		    var list = {};
		    var items = iq.getElementsByTagName('item');

		    if (items) {
		        for (var i = 0; i < items.length; i++) {
		            var item = items[i];
		            var jid = item.getAttribute('jid');
		            var affiliation = item.getAttribute('affiliation');
		            var nick = item.getAttribute('nick');
		            if (!jid) {
		                continue;
		            }
		            var n = _parseNameFromJidFn(jid);
		            list[n] = {
		                jid: jid,
		                affiliation: affiliation,
		                nick: nick,
		                name: n
		            };
		        }
		    }
		    return list;
		}

		// used for blacklist
		connection.prototype.getGroupBlacklist = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;

		    // var jid = _getJid(options, this);
		    var affiliation = 'admin'; //options.affiliation || 'admin';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'get', to: to });

		    iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation }).c('item', {
		        affiliation: 'outcast'
		    });

		    this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) {
		        log('getGroupBlackList');
		        sucFn(_parseGroupBlacklist(msginfo));
		    }, function () {
		        errFn();
		    });
		};

		// used for blacklist
		connection.prototype.removeGroupMemberFromBlacklist = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;

		    var jid = _getJid(options, this);
		    var affiliation = 'admin'; //options.affiliation || 'admin';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });

		    iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation }).c('item', {
		        affiliation: 'none',
		        jid: jid
		    });

		    this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) {
		        sucFn();
		    }, function () {
		        errFn();
		    });
		};

		/**
		 * changeGroupSubject 修改群名称
		 *
		 * @param options
		 */
		// <iq to='easemob-demo#chatdemoui_roomid@conference.easemob.com' type='set' id='3940489311' xmlns='jabber:client'>
		//     <query xmlns='http://jabber.org/protocol/muc#owner'>
		//         <x type='submit' xmlns='jabber:x:data'>
		//             <field var='FORM_TYPE'><value>http://jabber.org/protocol/muc#roomconfig</value></field>
		//             <field var='muc#roomconfig_roomname'><value>Room Name</value></field>
		//         </x>
		//     </query>
		// </iq>
		connection.prototype.changeGroupSubject = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;

		    // must be `owner`
		    var affiliation = 'owner';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });

		    iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation }).c('x', { type: 'submit', xmlns: 'jabber:x:data' }).c('field', { 'var': 'FORM_TYPE' }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up().c('field', { 'var': 'muc#roomconfig_roomname' }).c('value').t(options.subject).up().up().c('field', { 'var': 'muc#roomconfig_roomdesc' }).c('value').t(options.description);

		    this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) {
		        sucFn();
		    }, function () {
		        errFn();
		    });
		};

		/**
		 * destroyGroup 删除群组
		 *
		 * @param options
		 */
		// <iq id="9BEF5D20-841A-4048-B33A-F3F871120E58" to="easemob-demo#chatdemoui_1477462231499@conference.easemob.com" type="set">
		//     <query xmlns="http://jabber.org/protocol/muc#owner">
		//         <destroy>
		//             <reason>xxx destory group yyy</reason>
		//         </destroy>
		//     </query>
		// </iq>
		connection.prototype.destroyGroup = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;

		    // must be `owner`
		    var affiliation = 'owner';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });

		    iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation }).c('destroy').c('reason').t(options.reason || '');

		    this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) {
		        sucFn();
		    }, function () {
		        errFn();
		    });
		};

		/**
		 * leaveGroupBySelf 主动离开群组
		 *
		 * @param options
		 */
		// <iq id="5CD33172-7B62-41B7-98BC-CE6EF840C4F6_easemob_occupants_change_affiliation" to="easemob-demo#chatdemoui_1477481609392@conference.easemob.com" type="set">
		//     <query xmlns="http://jabber.org/protocol/muc#admin">
		//         <item affiliation="none" jid="easemob-demo#chatdemoui_lwz2@easemob.com"/>
		//     </query>
		// </iq>
		// <presence to="easemob-demo#chatdemoui_1479811172349@conference.easemob.com/mt002" type="unavailable"/>

		connection.prototype.leaveGroupBySelf = function (options) {
		    var self = this;
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;

		    // must be `owner`
		    var jid = _getJid(options, this);
		    var affiliation = 'admin';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });

		    iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation }).c('item', {
		        affiliation: 'none',
		        jid: jid
		    });

		    this.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) {
		        sucFn(msgInfo);
		        var pres = $pres({ type: 'unavailable', to: to + '/' + self.context.userId });
		        self.sendCommand(pres.tree());
		    }, function (errInfo) {
		        errFn(errInfo);
		    });
		};

		/**
		 * leaveGroup 被踢出群组
		 *
		 * @param options
		 */
		// <iq id="9fb25cf4-1183-43c9-961e-9df70e300de4:sendIQ" to="easemob-demo#chatdemoui_1477481597120@conference.easemob.com" type="set" xmlns="jabber:client">
		//     <query xmlns="http://jabber.org/protocol/muc#admin">
		//         <item affiliation="none" jid="easemob-demo#chatdemoui_lwz4@easemob.com"/>
		//         <item jid="easemob-demo#chatdemoui_lwz4@easemob.com" role="none"/>
		//         <item affiliation="none" jid="easemob-demo#chatdemoui_lwz2@easemob.com"/>
		//         <item jid="easemob-demo#chatdemoui_lwz2@easemob.com" role="none"/>
		//     </query>
		// </iq>
		connection.prototype.leaveGroup = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;
		    var list = options.list || [];
		    var affiliation = 'admin';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });
		    var piece = iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation });
		    var keys = Object.keys(list);
		    var len = keys.length;

		    for (var i = 0; i < len; i++) {
		        var name = list[keys[i]];
		        var jid = _getJidByName(name, this);

		        piece = piece.c('item', {
		            affiliation: 'none',
		            jid: jid
		        }).up().c('item', {
		            role: 'none',
		            jid: jid
		        }).up();
		    }

		    this.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) {
		        sucFn(msgInfo);
		    }, function (errInfo) {
		        errFn(errInfo);
		    });
		};

		/**
		 * addGroupMembers 添加群组成员
		 *
		 * @param options

		 Attention the sequence: message first (每个成员单独发一条message), iq second (多个成员可以合成一条iq发)
		 <!-- 添加成员通知：send -->
		 <message to='easemob-demo#chatdemoui_1477482739698@conference.easemob.com'>
		 <x xmlns='http://jabber.org/protocol/muc#user'>
		 <invite to='easemob-demo#chatdemoui_lwz2@easemob.com'>
		 <reason>liuwz invite you to join group '谢谢'</reason>
		 </invite>
		 </x>
		 </message>
		 <!-- 添加成员：send -->
		 <iq id='09DFB1E5-C939-4C43-B5A7-8000DA0E3B73_easemob_occupants_change_affiliation' to='easemob-demo#chatdemoui_1477482739698@conference.easemob.com' type='set'>
		 <query xmlns='http://jabber.org/protocol/muc#admin'>
		 <item affiliation='member' jid='easemob-demo#chatdemoui_lwz2@easemob.com'/>
		 </query>
		 </iq>
		 */

		connection.prototype.addGroupMembers = function (options) {
		    var sucFn = options.success || _utils.emptyfn;
		    var errFn = options.error || _utils.emptyfn;
		    var list = options.list || [];
		    var affiliation = 'admin';
		    var to = this._getGroupJid(options.roomId);
		    var iq = $iq({ type: 'set', to: to });
		    var piece = iq.c('query', { xmlns: 'http://jabber.org/protocol/muc#' + affiliation });
		    var len = list.length;

		    for (var i = 0; i < len; i++) {

		        var name = list[i];
		        var jid = _getJidByName(name, this);

		        piece = piece.c('item', {
		            affiliation: 'member',
		            jid: jid
		        }).up();

		        var dom = $msg({
		            to: to
		        }).c('x', {
		            xmlns: 'http://jabber.org/protocol/muc#user'
		        }).c('invite', {
		            to: jid
		        }).c('reason').t(options.reason || '');

		        this.sendCommand(dom.tree());
		    }

		    this.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) {
		        sucFn(msgInfo);
		    }, function (errInfo) {
		        errFn(errInfo);
		    });
		};

		/**
		 * acceptInviteFromGroup 接受加入申请
		 *
		 * @param options
		 */
		connection.prototype.acceptInviteFromGroup = function (options) {
		    options.success = function () {
		        // then send sendAcceptInviteMessage
		        // connection.prototype.sendAcceptInviteMessage(optoins);
		    };
		    this.addGroupMembers(options);
		};

		/**
		 * rejectInviteFromGroup 拒绝入群申请
		 *
		 * throw request for now 暂时不处理，直接丢弃
		 *
		 <message to='easemob-demo#chatdemoui_mt002@easemob.com' from='easmeob-demo#chatdemoui_mt001@easemob.com' id='B83B7210-BCFF-4DEE-AB28-B9FE5579C1E2'>
		 <x xmlns='http://jabber.org/protocol/muc#user'>
		 <apply to='easemob-demo#chatdemoui_groupid1@conference.easemob.com' from='easmeob-demo#chatdemoui_mt001@easemob.com' toNick='llllll'>
		 <reason>reject</reason>
		 </apply>
		 </x>
		 </message>
		 *
		 * @param options
		 */
		connection.prototype.rejectInviteFromGroup = function (options) {
		    // var from = _getJidByName(options.from, this);
		    // var dom = $msg({
		    //     from: from,
		    //     to: _getJidByName(options.to, this)
		    // }).c('x', {
		    //     xmlns: 'http://jabber.org/protocol/muc#user'
		    // }).c('apply', {
		    //     from: from,
		    //     to: this._getGroupJid(options.groupId),
		    //     toNick: options.groupName
		    // }).c('reason').t(options.reason || '');
		    //
		    // this.sendCommand(dom.tree());
		};

		connection.prototype.createGroupAsync = function (p) {
		    var roomId = p.from;
		    var me = this;
		    var toRoom = this._getGroupJid(roomId);
		    var to = toRoom + '/' + this.context.userId;
		    var options = this.groupOption;
		    var suc = p.success || _utils.emptyfn;

		    // Creating a Reserved Room
		    var iq = $iq({ type: 'get', to: toRoom }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' });

		    // Strophe.info('step 1 ----------');
		    // Strophe.info(options);
		    me.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) {
		        // log(msgInfo);

		        // for ie hack
		        if ('setAttribute' in msgInfo) {
		            // Strophe.info('step 3 ----------');
		            var x = msgInfo.getElementsByTagName('x')[0];
		            x.setAttribute('type', 'submit');
		        } else {
		            // Strophe.info('step 4 ----------');
		            Strophe.forEachChild(msgInfo, 'x', function (field) {
		                field.setAttribute('type', 'submit');
		            });
		        }

		        Strophe.info('step 5 ----------');
		        Strophe.forEachChild(x, 'field', function (field) {
		            var fieldVar = field.getAttribute('var');
		            var valueDom = field.getElementsByTagName('value')[0];
		            Strophe.info(fieldVar);
		            switch (fieldVar) {
		                case 'muc#roomconfig_roomname':
		                    _setText(valueDom, options.subject || '');
		                    break;
		                case 'muc#roomconfig_roomdesc':
		                    _setText(valueDom, options.description || '');
		                    break;
		                case 'muc#roomconfig_publicroom':
		                    // public 1
		                    _setText(valueDom, +options.optionsPublic);
		                    break;
		                case 'muc#roomconfig_membersonly':
		                    _setText(valueDom, +options.optionsMembersOnly);
		                    break;
		                case 'muc#roomconfig_moderatedroom':
		                    _setText(valueDom, +options.optionsModerate);
		                    break;
		                case 'muc#roomconfig_persistentroom':
		                    _setText(valueDom, 1);
		                    break;
		                case 'muc#roomconfig_allowinvites':
		                    _setText(valueDom, +options.optionsAllowInvites);
		                    break;
		                case 'muc#roomconfig_allowvisitornickchange':
		                    _setText(valueDom, 0);
		                    break;
		                case 'muc#roomconfig_allowvisitorstatus':
		                    _setText(valueDom, 0);
		                    break;
		                case 'allow_private_messages':
		                    _setText(valueDom, 0);
		                    break;
		                case 'allow_private_messages_from_visitors':
		                    _setText(valueDom, 'nobody');
		                    break;
		                default:
		                    break;
		            }
		        });

		        var iq = $iq({ to: toRoom, type: 'set' }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }).cnode(x);

		        me.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) {
		            me.addGroupMembers({
		                list: options.members,
		                roomId: roomId
		            });

		            suc(options);
		        }, function (errInfo) {
		            // errFn(errInfo);
		        });
		        // sucFn(msgInfo);
		    }, function (errInfo) {
		        // errFn(errInfo);
		    });
		};

		/**
		 * createGroup 创建群组
		 *
		 * 1. 创建申请 -> 得到房主身份
		 * 2. 获取房主信息 -> 得到房间form
		 * 3. 完善房间form -> 创建成功
		 * 4. 添加房间成员
		 * 5. 消息通知成员
		 * @param options
		 */
		connection.prototype.createGroup = function (options) {
		    this.groupOption = options;
		    var roomId = +new Date();
		    var toRoom = this._getGroupJid(roomId);
		    var to = toRoom + '/' + this.context.userId;

		    var pres = $pres({ to: to }).c('x', { xmlns: 'http://jabber.org/protocol/muc' }).up().c('create', { xmlns: 'http://jabber.org/protocol/muc' }).up();

		    // createGroupACK
		    this.sendCommand(pres.tree());
		};

		function _setText(valueDom, v) {
		    if ('textContent' in valueDom) {
		        valueDom.textContent = v;
		    } else if ('text' in valueDom) {
		        valueDom.text = v;
		    } else {
		        // Strophe.info('_setText 4 ----------');
		        // valueDom.innerHTML = v;
		    }
		}

		var WebIM = window.WebIM || {};
		WebIM.connection = connection;
		WebIM.utils = _utils;
		WebIM.statusCode = _code;
		WebIM.message = _msg.message;
		WebIM.doQuery = function (str, suc, fail) {
		    if (typeof window.cefQuery === 'undefined') {
		        return;
		    }
		    window.cefQuery({
		        request: str,
		        persistent: false,
		        onSuccess: suc,
		        onFailure: fail
		    });
		};

		module.exports = WebIM;

		if (false) {
		    module.hot.accept();
		}

	/***/ },

	/***/ 232:
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		;(function () {
		    'use strict';

		    var _utils = __webpack_require__(223).utils;
		    var Message = function Message(type, id) {
		        if (!this instanceof Message) {
		            return new Message(type);
		        }

		        this._msg = {};

		        if (typeof Message[type] === 'function') {
		            Message[type].prototype.setGroup = this.setGroup;
		            this._msg = new Message[type](id);
		        }
		        return this._msg;
		    };
		    Message.prototype.setGroup = function (group) {
		        this.body.group = group;
		    };

		    /*
		     * text message
		     */
		    Message.txt = function (id) {
		        this.id = id;
		        this.type = 'txt';
		        this.body = {};
		    };
		    Message.txt.prototype.set = function (opt) {
		        this.value = opt.msg;
		        this.body = {
		            id: this.id,
		            to: opt.to,
		            msg: this.value,
		            type: this.type,
		            roomType: opt.roomType,
		            ext: opt.ext || {},
		            success: opt.success,
		            fail: opt.fail
		        };

		        !opt.roomType && delete this.body.roomType;
		    };

		    /*
		     * cmd message
		     */
		    Message.cmd = function (id) {
		        this.id = id;
		        this.type = 'cmd';
		        this.body = {};
		    };
		    Message.cmd.prototype.set = function (opt) {
		        this.value = '';

		        this.body = {
		            to: opt.to,
		            action: opt.action,
		            msg: this.value,
		            type: this.type,
		            roomType: opt.roomType,
		            ext: opt.ext || {},
		            success: opt.success
		        };
		        !opt.roomType && delete this.body.roomType;
		    };

		    /*
		     * loc message
		     */
		    Message.location = function (id) {
		        this.id = id;
		        this.type = 'loc';
		        this.body = {};
		    };
		    Message.location.prototype.set = function (opt) {
		        this.body = {
		            to: opt.to,
		            type: this.type,
		            roomType: opt.roomType,
		            addr: opt.addr,
		            lat: opt.lat,
		            lng: opt.lng,
		            ext: opt.ext || {}
		        };
		    };

		    /*
		     * img message
		     */
		    Message.img = function (id) {
		        this.id = id;
		        this.type = 'img';
		        this.body = {};
		    };
		    Message.img.prototype.set = function (opt) {
		        opt.file = opt.file || _utils.getFileUrl(opt.fileInputId);

		        this.value = opt.file;

		        this.body = {
		            id: this.id,
		            file: this.value,
		            apiUrl: opt.apiUrl,
		            to: opt.to,
		            type: this.type,
		            ext: opt.ext || {},
		            roomType: opt.roomType,
		            onFileUploadError: opt.onFileUploadError,
		            onFileUploadComplete: opt.onFileUploadComplete,
		            success: opt.success,
		            fail: opt.fail,
		            flashUpload: opt.flashUpload,
		            width: opt.width,
		            height: opt.height,
		            body: opt.body,
		            uploadError: opt.uploadError,
		            uploadComplete: opt.uploadComplete
		        };

		        !opt.roomType && delete this.body.roomType;
		    };

		    /*
		     * audio message
		     */
		    Message.audio = function (id) {
		        this.id = id;
		        this.type = 'audio';
		        this.body = {};
		    };
		    Message.audio.prototype.set = function (opt) {
		        opt.file = opt.file || _utils.getFileUrl(opt.fileInputId);

		        this.value = opt.file;
		        this.filename = opt.filename || this.value.filename;

		        this.body = {
		            id: this.id,
		            file: this.value,
		            filename: this.filename,
		            apiUrl: opt.apiUrl,
		            to: opt.to,
		            type: this.type,
		            ext: opt.ext || {},
		            length: opt.length || 0,
		            roomType: opt.roomType,
		            file_length: opt.file_length,
		            onFileUploadError: opt.onFileUploadError,
		            onFileUploadComplete: opt.onFileUploadComplete,
		            success: opt.success,
		            fail: opt.fail,
		            flashUpload: opt.flashUpload,
		            body: opt.body
		        };
		        !opt.roomType && delete this.body.roomType;
		    };

		    /*
		     * file message
		     */
		    Message.file = function (id) {
		        this.id = id;
		        this.type = 'file';
		        this.body = {};
		    };
		    Message.file.prototype.set = function (opt) {
		        opt.file = opt.file || _utils.getFileUrl(opt.fileInputId);

		        this.value = opt.file;
		        this.filename = opt.filename || this.value.filename;

		        this.body = {
		            id: this.id,
		            file: this.value,
		            filename: this.filename,
		            apiUrl: opt.apiUrl,
		            to: opt.to,
		            type: this.type,
		            ext: opt.ext || {},
		            roomType: opt.roomType,
		            onFileUploadError: opt.onFileUploadError,
		            onFileUploadComplete: opt.onFileUploadComplete,
		            success: opt.success,
		            fail: opt.fail,
		            flashUpload: opt.flashUpload,
		            body: opt.body
		        };
		        !opt.roomType && delete this.body.roomType;
		    };

		    /*
		     * video message
		     */
		    Message.video = function (id) {};
		    Message.video.prototype.set = function (opt) {};

		    var _Message = function _Message(message) {

		        if (!this instanceof _Message) {
		            return new _Message(message, conn);
		        }

		        this.msg = message;
		    };

		    _Message.prototype.send = function (conn) {
		        var me = this;

		        var _send = function _send(message) {

		            message.ext = message.ext || {};
		            message.ext.weichat = message.ext.weichat || {};
		            message.ext.weichat.originType = message.ext.weichat.originType || 'webim';

		            var json = {
		                from: conn.context.userId || '',
		                to: message.to,
		                bodies: [message.body],
		                ext: message.ext || {}
		            };

		            var jsonstr = _utils.stringify(json);
		            var dom = $msg({
		                type: message.group || 'chat',
		                to: message.toJid,
		                id: message.id,
		                xmlns: 'jabber:client'
		            }).c('body').t(jsonstr);

		            if (message.roomType) {
		                dom.up().c('roomtype', { xmlns: 'easemob:x:roomtype', type: 'chatroom' });
		            }

		            setTimeout(function () {
		                if (typeof _msgHash !== 'undefined' && _msgHash[message.id]) {
		                    _msgHash[message.id].msg.fail instanceof Function && _msgHash[message.id].msg.fail(message.id);
		                }
		            }, 60000);
		            conn.sendCommand(dom.tree(), message.id);
		        };

		        if (me.msg.file) {
		            if (me.msg.body && me.msg.body.url) {
		                // Only send msg
		                _send(me.msg);
		                return;
		            }
		            var _tmpComplete = me.msg.onFileUploadComplete;
		            var _complete = function _complete(data) {

		                if (data.entities[0]['file-metadata']) {
		                    var file_len = data.entities[0]['file-metadata']['content-length'];
		                    me.msg.file_length = file_len;
		                    me.msg.filetype = data.entities[0]['file-metadata']['content-type'];
		                    if (file_len > 204800) {
		                        me.msg.thumbnail = true;
		                    }
		                }

		                me.msg.body = {
		                    type: me.msg.type || 'file',

		                    url: (location.protocol != 'https:' && conn.isHttpDNS ? conn.apiUrl + data.uri.substr(data.uri.indexOf("/", 9)) : data.uri) + '/' + data.entities[0]['uuid'],
		                    secret: data.entities[0]['share-secret'],
		                    filename: me.msg.file.filename || me.msg.filename,
		                    size: {
		                        width: me.msg.width || 0,
		                        height: me.msg.height || 0
		                    },
		                    length: me.msg.length || 0,
		                    file_length: me.msg.file_length || 0,
		                    filetype: me.msg.filetype
		                };
		                _send(me.msg);
		                _tmpComplete instanceof Function && _tmpComplete(data, me.msg.id);
		            };

		            me.msg.onFileUploadComplete = _complete;
		            _utils.uploadFile.call(conn, me.msg);
		        } else {
		            me.msg.body = {
		                type: me.msg.type === 'chat' ? 'txt' : me.msg.type,
		                msg: me.msg.msg
		            };
		            if (me.msg.type === 'cmd') {
		                me.msg.body.action = me.msg.action;
		            } else if (me.msg.type === 'loc') {
		                me.msg.body.addr = me.msg.addr;
		                me.msg.body.lat = me.msg.lat;
		                me.msg.body.lng = me.msg.lng;
		            }

		            _send(me.msg);
		        }
		    };

		    exports._msg = _Message;
		    exports.message = Message;
		})();

	/***/ },

	/***/ 233:
	/***/ function(module, exports) {

		"use strict";

		;(function () {
		    function Array_h(length) {
		        this.array = length === undefined ? [] : new Array(length);
		    }

		    Array_h.prototype = {
		        /**
		         * 返回数组长度
		         *
		         * @return {Number} length [数组长度]
		         */
		        length: function length() {
		            return this.array.length;
		        },

		        at: function at(index) {
		            return this.array[index];
		        },

		        set: function set(index, obj) {
		            this.array[index] = obj;
		        },

		        /**
		         * 向数组的末尾添加一个或多个元素，并返回新的长度。
		         *
		         * @param  {*} obj [description]
		         * @return {Number} length [新数组的长度]
		         */
		        push: function push(obj) {
		            return this.array.push(obj);
		        },

		        /**
		         * 返回数组中选定的元素
		         *
		         * @param  {Number} start [开始索引值]
		         * @param  {Number} end [结束索引值]
		         * @return {Array} newArray  [新的数组]
		         */
		        slice: function slice(start, end) {
		            return this.array = this.array.slice(start, end);
		        },

		        concat: function concat(array) {
		            this.array = this.array.concat(array);
		        },

		        remove: function remove(index, count) {
		            count = count === undefined ? 1 : count;
		            this.array.splice(index, count);
		        },

		        join: function join(separator) {
		            return this.array.join(separator);
		        },

		        clear: function clear() {
		            this.array.length = 0;
		        }
		    };

		    /**
		     * 先进先出队列 (First Input First Output)
		     *
		     * 一种先进先出的数据缓存器
		     */
		    var Queue = function Queue() {
		        this._array_h = new Array_h();
		    };

		    Queue.prototype = {
		        _index: 0,

		        /**
		         * 排队
		         *
		         * @param  {Object} obj [description]
		         * @return {[type]}     [description]
		         */
		        push: function push(obj) {
		            this._array_h.push(obj);
		        },

		        /**
		         * 出队
		         *
		         * @return {Object} [description]
		         */
		        pop: function pop() {
		            var ret = null;
		            if (this._array_h.length()) {
		                ret = this._array_h.at(this._index);
		                if (++this._index * 2 >= this._array_h.length()) {
		                    this._array_h.slice(this._index);
		                    this._index = 0;
		                }
		            }
		            return ret;
		        },

		        /**
		         * 返回队列中头部(即最新添加的)的动态对象
		         *
		         * @return {Object} [description]
		         */
		        head: function head() {
		            var ret = null,
		                len = this._array_h.length();
		            if (len) {
		                ret = this._array_h.at(len - 1);
		            }
		            return ret;
		        },

		        /**
		         * 返回队列中尾部(即最早添加的)的动态对象
		         *
		         * @return {Object} [description]
		         */
		        tail: function tail() {
		            var ret = null,
		                len = this._array_h.length();
		            if (len) {
		                ret = this._array_h.at(this._index);
		            }
		            return ret;
		        },

		        /**
		         * 返回数据队列长度
		         *
		         * @return {Number} [description]
		         */
		        length: function length() {
		            return this._array_h.length() - this._index;
		        },

		        /**
		         * 队列是否为空
		         *
		         * @return {Boolean} [description]
		         */
		        empty: function empty() {
		            return this._array_h.length() === 0;
		        },

		        clear: function clear() {
		            this._array_h.clear();
		        }
		    };
		    exports.Queue = Queue;
		})();

	/***/ }

	/******/ });

/***/ }

});