<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>framework\framework-base.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Framework.html">Framework</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/framework-base.html">framework-base</a></li>
                                <li><a href="../modules/historycontrol-base.html">historycontrol-base</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: framework\framework-base.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
﻿/**
 * 框架基类模块&lt;br&gt;
 * 提供一些基础的公共方法&lt;br&gt;
 * 所有模块都应继承自它&lt;br&gt;
 * @author yanglang
 * @version 1.0
 * @module framework-base
 */

require(&#x27;../../libs/utils&#x27;);
var Events = require(&#x27;../../libs/framework-events&#x27;);
var appConfig = require(&#x27;../../../../../configs/appConfig&#x27;);

/**
 * 当前模块对象
 * @private
 * @property {Framework} _currentModel
 */
var _currentModel = null;

var _fragmentCache = {};
var debug = false;

/**
 * websocket
 */
var _websocket = null;
var EVENT_LISTEN_PREFIX = &#x27;LISTENEVENT&#x27;;

/**
 * 父模块列表
 */
var parentModels = [];
parentModels.hasModel = function (model) {
    var has = false;
    for (var i = 0; i &lt; this.length; i++) {
        if (this[i] === model) {
            has = true;
            break;
        }
    }
    return has;
};

/**
 * 当前模块的上一个模块
 * 用于记录Pop类型的模块的上一个模块，用以还原currentModule的值
 * @type {null}
 * @private
 */
var _prevModule = null;


/**
 * 框架基类模块&lt;br&gt;
 * 提供一些基础的公共方法&lt;br&gt;
 * 所有模块都应继承自它&lt;br&gt;
 * 此基础模块将会接管所有子模块的展现工作&lt;br&gt;
 * 只需设置showType类型，就可以多种形态进行展现&lt;br&gt;
 * 目前支持弹窗与普通展现、无界面三种形式&lt;br&gt;
 * 此套架构的优点在于：解耦目前所有模块，功能上各模块互相提供API接口进行调用，各模块API由各自统一进行维护。&lt;br&gt;
 * 此外，由于采用CMD模式架构，所以理论上支持无限量模块数目进行加载。&lt;br&gt;
 * @version 1.0
 * @author 杨浪
 * @class Framework
 * @constructor
 *
 */
var Framework = function () {
    this.baseTitle = window.document.title;
};


Framework.prototype = {
    /**
     *
     * !!== 定义规范 ==!!，&lt;br&gt;
     * 必须实现此方法作为入口，&lt;br&gt;
     * @method init
     * @param {Object} options 初始参数(对象)
     *
     */
    init: function (options) {
        //初始化
        options = $.extend({},options);
        var _current = this.getCurrent();
        _current &amp;&amp; (options.showType != &#x27;Pop&#x27;) &amp;&amp; (!_current.finished) &amp;&amp; _current.finish();
        _prevModule = _current;
        debug &amp;&amp; console.log(&#x27;装载&#x27;+this.id);
        this.setCurrent();
        //由框架设置展现形式
        this.setShowType($.extend({}, options).showType);
        this.finished = false;
        Events.notifyWith(&#x27;init&#x27;,this, options);

    },
    /**
     * 对Framework框架进行扩展
     * @method extend 扩展模块
     * @param model 模块id 或 id列表
     * @param callback 回调方法
     */
    extend: function (model) {
        var that = this;
        var models = [];
        if (!$.isArray(model))
            models.push(model);
        else
            models = model;

        for(var i = 0;i&lt;models.length;i++){
            if (!parentModels.hasModel(models[i])) {
                parentModels.push(models[i]);
            }
        }
    },
    /**
     * 移除扩展
     * @method excludeExtension
     * @param modelId 扩展id
     */
    excludeExtension: function (modelId) {
        var that = this;
        for (var i = 0; i &lt; parentModels.length; i++) {
            if (parentModels[i].id == modelId) {
                parentModels.removeAt(i);
                i--;
            }
        }
    },
    /**
     * 批量移除扩展
     * @method excludeExtensions
     * @param modelIds 扩展id列表
     */
    excludeExtensions: function (modelIds) {
        for (var i = 0; i &lt; modelIds.length; i++) {
            this.excludeExtension(modelIds[i]);
        }
    },
    /**
     * 执行扩展模块的接口方法
     * @method _callExtendInterface
     * @param funName 接口方法名
     * @param param 可选参数
     */
    _callExtendInterface: function (funName, param) {
        if (!parentModels)
            return;
        for (var i = 0; i &lt; parentModels.length; i++) {
            if (parentModels[i][funName] &amp;&amp; $.isFunction(parentModels[i][funName]))
                parentModels[i][funName].call(this, param);
        }
    },
    /**
     * 当前模块被切换掉时，模块可以选择拒绝，
     * 默认同意&lt;br&gt;
     * 这是一个预留接口&lt;br&gt;
     * 有相应需求的模块实现此方法即可。&lt;br&gt;
     * 目前只针对账户中心实现了这个接口的判断，以供左侧菜单使用&lt;br&gt;
     * @method onClose
     * @param {Function} callback 回调方法 同样返回true或false
     * @param {Boolean} isSame 是否仍然是同一个模块进行刷新操作
     * @return {Boolean} true同意 false拒绝
     */
    onClose: function (callback, isSame) {
        return true;
    },
    /**
     * 设置应用标题
     * @method setBaseTitle
     * @chainable
     * @param {String} baseTitle 标题
     * @return {Framework} self
     */
    setBaseTitle: function (baseTitle) {
        this.baseTitle = baseTitle;
        return this;
    },
    /**
     * 获取应用标题
     * @method getBaseTitle
     * @chainable
     * @return {String} baseTitle 标题
     */
    getBaseTitle: function () {
        return this.baseTitle ? this.baseTitle : &#x27;未知标题&#x27;;
    },
    /**
     * 设置标题（仅弹窗时用）
     * @method setTitle
     * @chainable
     * @param {String} title 标题
     * @return {Framework} self
     */
    setTitle: function (title) {
        this.title = title;
        return this;
    },
    /**
     * 获取标题（仅弹窗时用）
     * @method getTitle
     * @chainable
     * @return {String} title 标题
     */
    getTitle: function () {
        return this.title ? this.title : &#x27;未知标题&#x27;;
    },
    /**
     * 设置对话框宽度（仅弹窗时用）
     * @method setWidth
     * @chainable
     * @param {Number} width 弹窗宽度
     * @return {Framework} self
     */
    setWidth: function (width) {
        this.width = width;
        return this;
    },
    /**
     * 获取对话框宽度（仅弹窗时用）
     * @method getWidth
     * @chainable
     * @return {Number} width 弹窗宽度
     */
    getWidth: function () {
        return this.width ? this.width : 400;
    },
    /**
     * 设置对话框高度（仅弹窗时用）
     * @method setHeight
     * @chainable
     * @param {Number} height 弹窗高度
     * @return {Framework} self
     */
    setHeight: function (height) {
        this.height = height;
        return this;
    },
    /**
     * 获取对话框高度（仅弹窗时用）
     * @method getHeight
     * @chainable
     * @return {Number} height 弹窗高度
     */
    getHeight: function () {
        return this.height ? this.height : 400;
    },
    /**
     * 设置是否需要标题栏（仅弹窗时用）
     * @method setNeedtitle
     * @chainable
     * @param {Boolean} flag 弹窗是否需要显示标题
     * @return {Framework} self
     */
    setNeedtitle: function (flag) {
        this.needtitle = flag !== undefined ? flag : true;
        return this;
    },
    /**
     * 是否需要标题栏（仅弹窗时用）
     * @method isNeedtitle
     * @chainable
     * @return {Boolean}
     */
    isNeedtitle: function () {
        //默认有标题栏
        return this.needtitle === undefined ? true : this.needtitle;
    },
    /**
     * 设置展现形式
     * @method setShowType
     * @chainable
     * @param {String} type 模块展现形式
     * &#x27;Normal&#x27; 账户中心mainview模式&lt;br&gt;
     * &#x27;Pop&#x27; 弹出框模式&lt;br&gt;
     * &#x27;Container&#x27; 自定义容器嵌入模式&lt;br&gt;
     * @returns {Framework} self
     */
    setShowType: function (type) {
        this.showType = (type ? type : &#x27;Normal&#x27;);
        return this;
    },
    /**
     * 获取展现形式&lt;br&gt;
     * 默认为Normal 账户中心的形式进行展现
     * @method getShowType
     * @chainable
     * @return {String} showType 模块展现形式
     */
    getShowType: function () {
        return this.showType === undefined ? &#x27;Normal&#x27; : this.showType;
    },
    /**
     * 获取显示区域容器对象
     * @method getContainer
     * @return {Dom} dom容器对象
     */
    getContainer: function () {
        return this.dom;
    },
    /**
     * 加载页面片段
     * @param url
     * @param callback
     */
    loadFragment:function(url,callback){
        var $def = $.Deferred();
        if(_fragmentCache[url]){
            setTimeout(function(){
                callback&amp;&amp;callback(_fragmentCache[url]);
                $def.resolve(_fragmentCache[url]);
            });
        }else{
            url += (/\?/g.test(url)?&#x27;&amp;&#x27;:&#x27;?&#x27;)+(new Date().getTime());
            $.get(url,function(data){
                if(!_fragmentCache[url])
                    _fragmentCache[url] = data;
                callback&amp;&amp;callback(data);
                $def.resolve(data);
            });
        }
        return $def.promise();
    },
    /**
     * get查询，异步执行，&lt;br&gt;
     * 返回json。&lt;br&gt;
     * @method query
     * @async
     * @param {String} url 查询地址
     * @param _param 参数对象 可选
     * @param {Function} _callback 回调方法 可选
     */
    query: function (url, _param, _callback) {
        var that = this, aLen = arguments.length, callback, param;
        if (aLen == 2) {
            if ($.isFunction(_param)) {
                callback = _param;
            }
        } else if (aLen == 3) {
            param = _param, callback = _callback;
        }
        return this._doGetJson(url, param, callback, true);
    },
    /**
     * get查询 同步执行&lt;br&gt;
     * 返回json&lt;br&gt;
     * @method querySync
     * @param {String} url 查询地址
     * @param _param 参数对象 可选
     * @param {Function} _callback 回调方法 可选
     */
    querySync: function (url, _param, _callback) {
        var that = this, aLen = arguments.length, callback, param;
        if (aLen == 2) {
            if ($.isFunction(_param)) {
                callback = _param;
            }
        } else if (aLen == 3) {
            param = _param, callback = _callback;
        }
        return this._doGetJson(url, param, callback, false);
    },
    /**
     * post保存，异步执行，&lt;br&gt;
     * 返回json。&lt;br&gt;
     * @method save
     * @async
     * @param {String} url 查询地址
     * @param _param 参数对象 可选
     * @param {Function} _callback 回调方法 可选
     */
    save: function (url, _param, _callback) {
        var that = this, aLen = arguments.length, callback, param;
        if (aLen == 2) {
            if ($.isFunction(_param)) {
                callback = _param;
            }
        } else if (aLen == 3) {
            param = _param, callback = _callback;
        }
        return this._doPostJson(url, param, callback, true);
    },
    /**
     * post保存 同步执行&lt;br&gt;
     * 返回json&lt;br&gt;
     * @method saveSync
     * @param {String} url 查询地址
     * @param _param 参数对象 可选
     * @param {Function} _callback 回调方法 可选
     */
    saveSync: function (url, _param, _callback) {
        var that = this, aLen = arguments.length, callback, param;
        if (aLen == 2) {
            if ($.isFunction(_param)) {
                callback = _param;
            }
        } else if (aLen == 3) {
            param = _param, callback = _callback;
        }
        return this._doPostJson(url, param, callback, false);
    },
    /**
     * 执行post查询&lt;br&gt;
     * 返回json&lt;br&gt;
     * 内部使用&lt;br&gt;
     * @method _doPostJson
     * @private
     * @param {String} url 查询地址
     * @param param 参数对象
     * @param {Function} callback 回调方法
     * @param {Boolean} async 是否异步
     */
    _doPostJson: function (url, param, callback, async) {
        var ajax = $.ajax({
            url: url,
            type: &#x27;post&#x27;,
            dataType: &#x27;json&#x27;,
            contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
            async: async,
            data: param,
            cache:false,
            success: function (json) {
                if (callback)
                    callback(json);
            },
            error: function(){
                console.log(&quot;error&quot;);
            }
        });
        return ajax;
    },
    /**
     * 执行post查询&lt;br&gt;
     * 返回json&lt;br&gt;
     * 内部使用&lt;br&gt;
     * @method _doPostJson
     * @private
     * @param {String} url 查询地址
     * @param param 参数对象
     * @param {Function} callback 回调方法
     * @param {Boolean} async 是否异步
     */
    _doGetJson: function (url, param, callback, async) {
        var ajax = $.ajax({
            url: url,
            type: &#x27;get&#x27;,
            dataType: &#x27;json&#x27;,
            contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
            async: async,
            cache:false,
            data: param,
            success: function (json) {
                if (callback)
                    callback(json);
            },
            error: function(){
                console.log(&quot;error&quot;);
            }
        });
        return ajax;
    },
    /**
     * 拼凑字符串
     * @method stringifyParam
     * @param {Object} param 参数
     * @split {String} param 分隔符1
     * @split2 {String} param 分隔符2
     * @return {String} 字符串结果
     */
    stringifyParam:function(param,split1,split2){
        if(!param)
            return &#x27;&#x27;;
        var arr = [];
        for(var key in param){
            arr.push(key+split1+param[key]);
        }
        return arr.join(split2);
    },
    /**
     * 设置显示区域容器的内容&lt;br&gt;
     * 当使用此方法时，会自动按照setShowType所设定的展现方式进行展现&lt;br&gt;
     * 当未设置setShowType时，默认使用Normal账户中心嵌入式进行展现&lt;br&gt;
     * 设置为Pop时，会使用弹窗控件进行弹窗展示
     * 设置为Container时，会使用传入的dom容器进行嵌入展示
     * @method render
     * @param data html数据
     * @return {Dom} dom容器对象
     */
    render: function (data) {
        var that = this;
        switch (this.getShowType()) {
            case &#x27;Normal&#x27;:
                var $mainview = $(&quot;#framework-content-main&quot;);
                $mainview.html(data);
                that.dom = $mainview;
                break;
            case &#x27;Pop&#x27;:
                var $pop = $(&#x27;&lt;div class=&quot;framework_dialog&quot;&gt;&lt;/div&gt;&#x27;).appendTo($(&#x27;body&#x27;));
                var pop = $pop.dialog({
                    title: this.getTitle(),
                    width: this.getWidth(),
                    height: this.getHeight(),
                    closed: false,
                    content:data,
                    modal: true,
                    collapsible:true,
                    minimizable:false,
                    maximizable:true,
                    maximized:false,
                    resizable:true,
                    onBeforeClose : function() {
                        that.finish();
                        return false;
                    },
                    onMove:function(left,top){
                        that.onMove(left,top);
                    },
                    onResize:function(){
                        that.dialogResize &amp;&amp; $.isFunction(that.dialogResize) &amp;&amp; that.dialogResize.apply(that,parentModels.slice.call(arguments,0));
                    }
                });
                that.dom = $pop.children();
                pop.parent().addClass(&#x27;uk-animation-scale-up&#x27;).next().addClass(&#x27;uk-animation-scale-up&#x27;);
                that.pop = pop;
                break;
            case &#x27;NoUI&#x27;:
                that.dom = null;
                break;
        }
        Events.notifyWith(&#x27;onRendered&#x27;,that, that.dom);
        setTimeout(function(){
            Events.notify(&#x27;onWindowResize&#x27;);
        },100);
        var $input = $(&#x27;input[autofocus]&#x27;,that.dom);
        $input.length&gt;0&amp;&amp;$input[0].focus();
        return that.dom;
    },
    dialogResize:$.noop,
    _closeDialog:function(){
        var that = this;
        if(this.pop){
            this.pop.parent().removeClass(&#x27;uk-animation-scale-up&#x27;).next().removeClass(&#x27;uk-animation-scale-up&#x27;);
            setTimeout(function(){
                that.pop.parent().addClass(&#x27;uk-animation-reverse uk-animation-scale-up&#x27;).next().addClass(&#x27;uk-animation-reverse uk-animation-scale-up&#x27;);
                setTimeout(function(){
                    that.pop.dialog(&#x27;destroy&#x27;);
                    that.pop = null;
                },200);
            },50);

        }
    },
    /**
     * 当模块为弹出框形式时，拖动后的回调函数
     * 等待子类实现
     * @method onMove
     * @param left 左位置
     * @param top  上位置
     */
    onMove:function(left,top){},
    /**
     * 添加回调方法&lt;br&gt;
     * 一般来说，当调用某个模块进行处理某项业务时，其处理完毕之后需要一个回调通知，调用此方法添加即可，同一个模块可以添加多个回调方法。&lt;br&gt;
     * 模块处理应遵循业务处理完毕之后调用自身继承下来的finish方法以声明此模块任务结束。&lt;br&gt;
     * @method addCallback
     * @chainable
     * @param {Function} callback 方法
     */
    addCallback: function (callback) {
        if (!this._callbacks)
            this._callbacks = [];
        this._callbacks.push({
            model: this,
            func: callback
        });
        return this;
    },
    /**
     * 清空回调堆栈
     * @method clearCallback
     */
    clearCallback: function () {
        if (this._callbacks)
            this._callbacks.length = 0;
    },
    /**
     * 模块任务结束&lt;br&gt;
     * 此方法的意义在于，当前模块结束对主视图的持有&lt;br&gt;
     * @method finish
     * @chainable
     * @return {Framework} self
     */
    finish: function () {
        if (this._callbacks) {
            var callbackcount = this._callbacks.length;
        } else
            var callbackcount = 0;

        if (this.getShowType() === &#x27;Pop&#x27;) {
            if (this.pop != null)
                this._closeDialog();
            _prevModule &amp;&amp; this.setCurrent.apply(_prevModule);
        }
        Events.notifyWith(&#x27;onFinished&#x27;,this);

        if (this._callbacks) {
            callbackcount != 0 ? this._executeCallback.apply(this, arguments) : &#x27;&#x27;;
            this._callbacks.length = 0;//清空回调
        }
        debug &amp;&amp; console.log(&#x27;卸载&#x27;+this.id);
        this.finished = true;
        this.dom = null;
        return this;
    },
    /**
     * 执行回调方法列表
     * @method _executeCallback
     * @private 内部使用
     */
    _executeCallback: function () {
        var callbacks = this._callbacks;
        for (var i = 0, len = callbacks.length; i &lt; len; i++) {
            callbacks[i].func.apply(this, arguments);
        }
    },
    /**
     * 设置当前模块&lt;br&gt;
     * 此方法的意义在于在有多个弹窗模块共存时，以声明模块当前模块。&lt;br&gt;
     * 内部若如果存在账户中心菜单选中的回调方法，则调用。
     * @method setCurrent
     */
    setCurrent: function () {
        _currentModel = this;
    },
    /**
     * 获取当前模块
     * @method getCurrent
     * @return {Framework} FrameworkBase的子类对象
     */
    getCurrent: function () {
        return _currentModel;
    },
    /**
     * 提供给外部使用的插件加载方式
     * 由子类实现该方法，并判断哪些模块是属于自己的，加载到相应的container内即可。
     * @method loadWidgets
     * @param {Object} widgetConfigs [{container:jQueryDom,module:&#x27;./attence-analyse-widgets/attence-analyse-chart1&#x27;}]
     */
    loadWidgets:function(widgetConfigs){
        return false;
    },
    /**
     * 提供给外部使用的插件销毁方式
     * 由子类实现该方法
     * @method destoryWidgets
     */
    destoryWidgets:function(){
        return false;
    },
    /**
     * 提供给外部使用的插件尺寸调整方法
     * @method resizeWidgets
     */
    resizeWidgets:function(){
        return false;
    },
    /**
     * toast 提示方法
     * @method toast
     * @param {String} msg 提示信息
     * @param {Integer} timeout 超时时长
     */
    toast:function(msg,timeout){
        var toast = document.createElement(&#x27;div&#x27;);
        toast.style.opacity = &#x27;0&#x27;;
        toast.style.padding = &#x27;7px 10px&#x27;;
        toast.style.minWidth = &#x27;80px&#x27;;
        toast.style.color = &#x27;#fff&#x27;;
        toast.style.textAlign = &#x27;center&#x27;;
        toast.style.position = &#x27;fixed&#x27;;
        toast.style.zIndex = &#x27;99999999999&#x27;;
        toast.style.bottom = &#x27;10%&#x27;;
        toast.style.left = &#x27;50%&#x27;;
        toast.style.borderRadius = &#x27;3px&#x27;;
        toast.style.fontSize = &#x27;14px&#x27;;
        toast.style.transform = &#x27;translateX(-50%)&#x27;;
        toast.style.transition = &#x27;opacity .3s ease&#x27;;
        toast.style.backgroundColor = &#x27;rgba(39, 39, 39, 0.6)&#x27;;
        toast.innerHTML = &#x27;&lt;p&gt;&#x27;+msg+&#x27;&lt;/p&gt;&#x27;;
        document.body.appendChild(toast);
        setTimeout(function(){
            toast.style.opacity = &#x27;1&#x27;;
        },50);
        setTimeout(function(){
            toast.style.opacity = &#x27;0&#x27;;
            setTimeout(function(){
                document.body.removeChild(toast);
            },300);
        },timeout?timeout:2000);
    },
    /* options的默认值
     *  表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。
     *  options.leading = true;
     * 表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。
     *  options.trailing = true;
     * 注意：当options.trailing = false时，效果与上面的简单实现效果相同
     * @method throttle
     * @param {Function} func 回调方法
     * @param {Integer} wait 等待时长
     */
    throttle : function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        };
        return function() {
            var now = Date.now();
            if (!previous &amp;&amp; options.leading === false) previous = now;
            // 计算剩余时间
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            // 当到达wait指定的时间间隔，则调用func函数
            // 精彩之处：按理来说remaining &lt;= 0已经足够证明已经到达wait的时间间隔，但这里还考虑到假如客户端修改了系统时间则马上执行func函数。
            if (remaining &lt;= 0 || remaining &gt; wait) {
                // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔，但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            } else if (!timeout &amp;&amp; options.trailing !== false) {
                // options.trailing=true时，延时执行func函数
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    },
    /* options的默认值
     *  表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。
     *  options.leading = true;
     * 表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。
     *  options.trailing = true;
     * 注意：当options.trailing = false时，效果与上面的简单实现效果相同
     * @method debounce
     * @param {Callback} func 回调方法
     * @param {Integer} wait 等待时长
     */
    debounce : function(func, wait, immediate) {
        // immediate默认为false
        var timeout, args, context, timestamp, result;

        var later = function() {
            // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last &lt; wait &amp;&amp; last &gt;= 0一直为true，从而不断启动新的计时器延时执行func
            var last = Date.now() - timestamp;

            if (last &lt; wait &amp;&amp; last &gt;= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = Date.now();
            // 第一次调用该方法时，且immediate为true，则调用func函数
            var callNow = immediate &amp;&amp; !timeout;
            // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    },
    /* 
     * websocket调用 
     * @method wsCall
     * @param {String} eventName 服务端事件名
     * @param {Object} data 数据
     * @param {Function} callback 回调方法
     */
    wsCall:function(eventName,data,callback){
        var tmpId = Events.EVENT_PREFIX + &#x27;_&#x27; + (new Date()).getTime();
        Events.subscribe(tmpId,function(data){
            callback &amp;&amp; callback(data);
        });
        _websocket.send(JSON.stringify({
            callbackId:tmpId,
            clientId:_websocket.client_id,
            eventName:eventName,
            data:data
        }));
        return tmpId;
    },
    /* 
     * websocket监听
     * @method wsListen
     * @param {String} eventName 服务端事件名
     * @param {Object} data 数据
     * @param {Function} callback 回调方法
     */
    wsListen:function(eventName,data,callback){
        var tmpId = EVENT_LISTEN_PREFIX + &#x27;_&#x27; + (new Date()).getTime();
        Events.subscribe(tmpId,function(data){
            callback &amp;&amp; callback(data);
        });
        _websocket.send(JSON.stringify({
            callbackId:tmpId,
            clientId:_websocket.client_id,
            eventName:eventName,
            data:data
        }));
        return tmpId;
    },
    /* 
     * websocket取消监听
     * @method wsUnListen
     * @param {String} id 事件id
     */
    wsUnListen:function(id){
        Events.unsubscribe(id);
    }
};

var frameWork = window.fw = new Framework();


/**======================订阅resize事件，通过debounce进行函数节流处理start================**/
/**
 * 订阅resize事件，通过debounce进行函数节流处理
 */
var resize = function(){
    try{
        Events.notify(&#x27;onWindowResize&#x27;);
    }catch(e){}
};

$(window).resize(frameWork.debounce(resize,70));
/**======================订阅resize事件，通过debounce进行函数节流处理end================**/



/**======================websocket 封装 start================**/
_websocket = new WebSocket(&#x27;ws://&#x27;+location.host.split(&#x27;:&#x27;)[0]+&#x27;:&#x27;+appConfig.WSPORT);
_websocket.onopen = function(){
};
_websocket.onclose  = function(){
  console.log(&#x27;ws close&#x27;);
};
_websocket.onerror  = function(){
  console.log(&#x27;ws onerror &#x27;);
};
_websocket.onmessage  = function(e){
    try{
        transfer(e);
    }catch(ex){
        console.log(ex);
    }
};
var CLIENT_ID_REG = /^__CLIENT_ID__:(.*)$/;
function transfer(e){
    var data = e.data;
    if(data.match(CLIENT_ID_REG)){
        _websocket.client_id = RegExp.$1;
    }else{
        var data = JSON.parse(e.data);
        Events.notify(data.callbackId,data.data);
    }

}


/**======================websocket 封装 end================**/



module.exports = frameWork;












    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
